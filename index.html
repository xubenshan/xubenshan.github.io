<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>考研er的精神所</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="纸上得来终觉浅，觉知此事须躬行">
<meta property="og:type" content="website">
<meta property="og:title" content="考研er的精神所">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="考研er的精神所">
<meta property="og:description" content="纸上得来终觉浅，觉知此事须躬行">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="才疏学浅的小熊">
<meta name="twitter:card" content="summary">
  
  
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">考研er的精神所</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">欢迎加入</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-post复习考研政治的感悟" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/07/15/post%E5%A4%8D%E4%B9%A0%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%E7%9A%84%E6%84%9F%E6%82%9F/" class="article-date">
  <time datetime="2023-07-15T09:52:30.000Z" itemprop="datePublished">2023-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/07/15/post%E5%A4%8D%E4%B9%A0%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%E7%9A%84%E6%84%9F%E6%82%9F/">复习考研政治的感悟</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;
int main()
&#123;

&#125;
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/15/post%E5%A4%8D%E4%B9%A0%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%E7%9A%84%E6%84%9F%E6%82%9F/" data-id="clk3tyxru0000p0s99qtchpnz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%80%83%E7%A0%94%E6%84%9F%E6%82%9F/" rel="tag">考研感悟</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-大唐杯经验分享" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/07/15/%E5%A4%A7%E5%94%90%E6%9D%AF%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/" class="article-date">
  <time datetime="2023-07-15T09:25:19.000Z" itemprop="datePublished">2023-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/07/15/%E5%A4%A7%E5%94%90%E6%9D%AF%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">大唐杯经验分享</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="大唐杯备考建议分享"><a href="#大唐杯备考建议分享" class="headerlink" title="大唐杯备考建议分享"></a>大唐杯备考建议分享</h1><blockquote>
<p>有很多同学私信或者在群里问我该怎么去准备大唐杯，我总结了学习经验分享给大家。</p>
</blockquote>
<h2 id="一、学习路线"><a href="#一、学习路线" class="headerlink" title="一、学习路线"></a>一、学习路线</h2><h3 id="时间安排"><a href="#时间安排" class="headerlink" title="时间安排"></a>时间安排</h3><ul>
<li><p>二月份（选择）</p>
<p>准备选择题。该怎么准备。首先将培训视频中的内容全部过一遍。一个月的时间足够了。在听视频的同时将一些重点的内容记下来。哪些是重点内容，群文件里面有思维导图，里面的知识点就是重点.听视频重点听这些内容。如果二月底才开始准备，那么看完所有视频要花费的时间太多了，就不要全看了。选择重点部分看。5G网络架构与组网部署，协议与信令，5G常见参数和物理层过程（A组视频有这部分，b组可以去B站找去年的视频看这部分）这四个视频可以重点看一下。如果有同学进度比较快，那么视频看完之后就可以去做知识点总结。按照思维导图知识点的顺序，把涉及到的知识点详细整理下来。这个工作我也会做，预计三月中旬做完之后会发到QQ群里面。</p>
</li>
<li><p>三月份（选择+仿真）</p>
<p>如果你没有时间做知识点总结，那么直接看我总结的知识点。知识点弄熟以后，就可以刷题了。我建议先去做这两年的真题，真题已经发到群里面了，解析和参考答案会在三月初发布。通过做这些真题去感受下比赛的难度，考察的角度，重点。另外网盘里面有很多题库，有时间就多刷一下，拓展下视野。我也会把一些我觉得可能会考的题目发到群里。另外三月份重点去准备仿真，考哪些内容群文件仿真文件夹里面有。该怎么去准备呢？常规题目基站开通调测车联网B站，网盘上有很多资料。另外仔细看官方第二次直播提到的仿真内容：物理层过程，信息通信技术以及移动性管理。这几部分知识如果有时间，我也会去做总结，发到群里面。赛前一周官方会开通仿真平台，一定要把上面的题目一定弄明白，那是基础内容，考试的时候只会更难。</p>
</li>
<li><p>赛前（三月底四月初）</p>
<p>考前一定要再过一遍总结的知识点，以及这两年的真题。</p>
<p>大唐杯比赛并没有大家想的那么难，按部就班的照我说的去做，保底省二。</p>
</li>
</ul>
<h2 id="二、一些问题的说明"><a href="#二、一些问题的说明" class="headerlink" title="二、一些问题的说明"></a>二、一些问题的说明</h2><ol>
<li>看视频看不懂怎么办</li>
</ol>
<p>第一次看，听不懂很正常，不懂的一定要多听几遍。另外网盘里面有知识点资料，可以去里面找知识点，辅助理解视频内容。还有很多参考书籍也可以看看，重点看《5G系统技术原理与实现》。后面我也会在这本书中标记重点。</p>
<ol start="2">
<li>什么时候比赛</li>
</ol>
<p>还没定，预计三月末四月初，等报名结束官方就会通知。</p>
<ol start="3">
<li>培训视频在哪看</li>
</ol>
<p>学唐里面看。指导老师会给你开通账号密码。学唐不是官网。</p>
<p><a target="_blank" rel="noopener" href="https://dtmobile.yunxuetang.cn/">学唐链接</a></p>
<p><a target="_blank" rel="noopener" href="https://dtcup.dtxiaotangren.com/">官网链接</a></p>
<p>另外如果现在还没有学唐的账号，可以去B站看去年的省赛培训视频。内容基本一样。</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1W3411K7FZ/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&vd_source=5940e85c0b18a907a0fdea51914b4f65">培训视频</a></p>
<ol start="4">
<li>在哪里练习仿真</li>
</ol>
<p>仿真平台现在还没开放，考前一周会开放。</p>
<ol start="5">
<li>今年新增的两个考点信息通信技术和工程概论该怎么去准备</li>
</ol>
<p>这两部分资料我会去整理发到群里面，另外工程概论涉及到的参考书目，等开学（2.11）我买了之后扫描成电子版发到群里面。</p>
<p>另外第二次官方直播有对信息通信技术的讲解，可以去看看。信息通信技术很有可能出现在仿真里面，毕竟它的占比20%。工程概论要根据思维导图在参考书目中找到对应的知识点。</p>
<ol start="6">
<li>关于资料的说明</li>
</ol>
<p>网盘资料链接在群公告里面，里面的内容是花钱买的或者网上搜到的，做了下整理汇总。题库里面的题目答案是否正确我也不知道，因为我还没有做。里面的知识点总结我觉得很好，里面还有很多有用的东西，希望大家一定要好好利用。资料多没用什么用，不看和没有一样。</p>
<ol start="7">
<li>可以只刷题库吗</li>
</ol>
<p>题库太多根本刷不完，另一方面考试只会有部分原题，大部分还是要靠你平时的学习积累，培训视频一定要过一遍，对知识有个大致的理解，刷题的时候效率才会高。另外今年新增了信息通信技术和工程概论知识点，这两部分没有题库。</p>
<h2 id="三、写在后面"><a href="#三、写在后面" class="headerlink" title="三、写在后面"></a>三、写在后面</h2><p>  创建QQ群的目的，一方面给大家分享下学习资料，不用在去花冤枉钱，买到很多4G的资料。另一方面也是希望监督自己，今年取得一个不错的名次。有句话我很喜欢，与君共勉。</p>
<p>  我辈既务斯业，便当专心用功。<br>我要说的就这些，后面想起别的来会继续补充。<br>希望大家今年都能取得很好的成绩！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/15/%E5%A4%A7%E5%94%90%E6%9D%AF%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/" data-id="clk3szey10000iks920p23ff5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%A7%E5%94%90%E6%9D%AF/" rel="tag">大唐杯</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/07/15/%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2023-07-15T09:25:19.000Z" itemprop="datePublished">2023-07-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/07/15/%E7%AE%97%E6%B3%95/">算法——搜索专题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/acdd5d863020486a920cbece48dbe12d.gif#pic_center" alt="在这里插入图片描述"></p>
<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>蓝桥杯省赛将在4月初举行，距离比赛也就剩一个多月的时间。为了提高自己的编程能力，在比赛中取得比较👌的成绩。接下来的一个多月我会在博客中更新蓝桥杯的学习。争取在考前将一些重要的算法过一遍。<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/89a67bbb0969467587a73d313071f5bb.gif#pic_center" alt="在这里插入图片描述"><br>蓝桥杯常考的算法我整理到了一张思维导图里面，小伙伴可以看一下噢。<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/a63bde7e7247449f9b3b780d4ddd2db7.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>这张蓝桥杯思维导图可能不太全面，以后会经常补充的。。</p>
</blockquote>
<p>我是这样想滴，我会对常考的算法做个专题总结，分专题来讲。文章更新的速度呢取决于我刷题的速度啦！ 因为每写一个专题必然要写运用到这种算法的题目啦~~~鲁迅先生说过~~  “只讲解算法思想，不实际运用就是在耍流氓”。写蓝桥杯文章的过程是这个样子的，先确定要写哪个专题，然后呢大量刷题，模板题啦，经典题啦，最最重要的是历届的蓝桥杯真题啦。刷完之后呢做总结理清这种算法的基本思路，最后就形成了一篇蓝桥杯备考文章啦。当然文章是要时常更改补充的，因为在刷题的过程中可能对某些算法思想有了新的感悟~也要参加蓝桥杯的小伙伴们可以一起期待噢，关注我一定不会让你失望的。噢还有我参加的是C++组所以呢我写的题解也是C++的。</p>
<blockquote>
<p>我的CSDN博客 <a target="_blank" rel="noopener" href="https://blog.csdn.net/ccevv/">https://blog.csdn.net/ccevv/</a></p>
</blockquote>
<hr>
<p>好啦接下来进入正题。<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/caa97b1a74dc41959dd23b2ef973a6e6.png#pic_center" alt="在这里插入图片描述"><br>我们知道蓝桥杯俗称暴力杯，搜索在蓝桥杯中是最最基本的算法思想。学会DFS和BFS是在蓝桥杯比赛中取得好成绩的基础。我会从这几个方面入手，给小伙伴们详细讲解搜索专题。<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/7d631a7e65bb430c9c1015d59f642b96.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>本篇的内容主要有以下几个方面噢，小伙伴们可以有个大致了解。</p>
<blockquote>
<p>DFS基本思想(DFS+回溯）<br>深度优先搜索模板<br>DFS例题<br>剪枝思想<br>剪枝思想在DFS中的应用</p>
</blockquote>
<hr>
<p>@[TOC]</p>
<hr>
<h2 id="一、深度优先搜索-DFS-回溯"><a href="#一、深度优先搜索-DFS-回溯" class="headerlink" title="一、深度优先搜索(DFS)+回溯"></a>一、深度优先搜索(DFS)+回溯</h2><p><code>DFS</code>是一种搜索的策略，简单来说就是一条路走到黑。当走到尽头之后就回退到上一个结点，继续一条路走到黑。回退的过程就叫做<strong>回溯</strong>。<br><code>DFS</code>一般采用<strong>递归</strong>的方式实现。</p>
<blockquote>
<p>对递归的详细讲解会在以后出一个独立的专题，小伙伴们可以期待一下噢！</p>
</blockquote>
<p><code>DFS</code>可以用一个递归搜索树来形象描述，那这棵树长什么样子呢，小伙伴们继续往下看。<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/b46f5fe9bde34fbd907b714c6ea1284c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>事实上对所有的合法<code>DFS</code>求解过程都可以把它画成树的形式，死胡同就相当于叶子结点。分岔口就相当于非叶子结点。</p>
<blockquote>
<p>对某个DFS类型的题目，不妨把一些状态作为树的结点，问题就变得很直观了。</p>
</blockquote>
<p><code>DFS</code>搜索的顺序是A-B-D-E-C-F。从结点A出发，它有两条路可以走，我们选择最左边那一条，到达结点B，结点B有两个分支，选择最左边那个，到达结点D。结点D没有路可走了也就是到达死胡同了，返回上一个结点B，也就是回溯的过程。B还有一条路可走，到达结点E。同理结点E回溯到结点B，结点B没有分支了，回溯到上一个结点A，结点A还有一个分支可以走，到达结点C,结点C有一个分支到达结点F，结点F是死胡同。至此所有的结点都访问了，搜索结束。</p>
<blockquote>
<p>其实DFS的搜索顺序和树的先序遍历是一样的。树的先序遍历就是根左右。</p>
</blockquote>
<p>从递归树我们就能看出<code>DFS</code>的时间复杂度是很高的，是$O(2^n)$。所以我们常说暴力搜索嘛，就是因为它时间复杂度太高了，当数据很大时很容易就<code>TLE(</code>超时)的。同时我们还能看出<code>DFS</code>会走遍所有的路径，并且走到死胡同就代表一条完整的路径形成。因此&#x3D;&#x3D;深度优先搜索是一种枚举所有路径，遍历所有情况的搜索策略&#x3D;&#x3D;。</p>
<hr>
<h2 id="二、DFS模板"><a href="#二、DFS模板" class="headerlink" title="二、DFS模板"></a>二、DFS模板</h2><blockquote>
<p>在备战蓝桥杯的过程中记住一些算法模板还是非常重要滴。</p>
</blockquote>
<pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;
bool check()
&#123;
    ...
&#125;
void dfs()
&#123;
    if (满足边界条件)
    &#123;
        
        return;
    &#125;
    for (int i = 0; i &lt; 可扩展的路径数; i++)
    &#123;
        if (check())
        &#123;
            修改现场;
            dfs(下一种情况);
            还原现场;
        &#125;
    &#125;
&#125;	
</code></pre>
<blockquote>
<p>模板不是固定不变的，我们要根据题目灵活地运用它。</p>
</blockquote>
<hr>
<h2 id="三、DFS经典例题"><a href="#三、DFS经典例题" class="headerlink" title="三、DFS经典例题"></a>三、DFS经典例题</h2><h3 id="1-模板题——迷宫问题"><a href="#1-模板题——迷宫问题" class="headerlink" title="1.模板题——迷宫问题"></a>1.模板题——迷宫问题</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1605">题目链接</a><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/76bfafbf85ae400bbf980124689c8b74.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>题目分析</strong></p>
<blockquote>
<p>迷宫问题是拿来练习DFS与BFS很经典的题目。迷宫问题有很多种问法，比如迷宫从起点到终点有没有路径，有几条，最短路径是多少。</p>
</blockquote>
<p>求从起点到终点的方案数显而易见也是要用<code>DFS</code>，遍历所有的情况。我们要考虑这样一个问题，迷宫里的某点<code>(x,y)</code>是否要被访问呢。当这点是障碍物肯定不能访问，该点不在迷宫里面也不能访问，该点访问过了那就不能访问了。(题目中有每个方格最多经过一次)。因此我们需要一个<code>check()</code>函数来判断某一点是否合法。合法我们就去访问该点。</p>
<blockquote>
<p>其实这个过程就是一个剪枝的过程，根据题目条件限制，剪掉一些不可能存在解的分支。</p>
</blockquote>
<p>另外我们该如何知道某点是障碍点呢，可以设置一个map数组来表示该迷宫。</p>
<ul>
<li>当<code>map[x][y]==1</code>时表示该点是障碍点 </li>
<li><code>map[x][y]==0</code>表示该点是正常点</li>
</ul>
<p><strong>AC代码</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;

const int N = 100;

int dx[4] = &#123;0, 0, -1, 1&#125;;
int dy[4] = &#123;1, -1, 0, 0&#125;;//方向数组技巧
int n, m, T;//n行m列T障碍总数
int ans;//记录方案总数
int sx, sy, fx, fy, l, r;//起点坐标(sx,sy)终点坐标(fx,fy)障碍点坐标(l,r)
bool visited[N][N];//记录某点是否被访问过
int map[N][N];//map[i][j] == 1表示是障碍

bool check(int x, int y)//check某点是否合法
&#123;
    if (x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; m) return false;//该点出界不合法
    if (map[x][y]) return false;//该点是障碍点不合法
    if (visited[x][y]) return false;//该点被访问过不合法
    return true;//其他情况访问合法
&#125;

void dfs(int x, int y)//dfs维护点的坐标参数
&#123;
    if (x == fx &amp;&amp; y == fy)//满足边界条件，到达终点
    &#123;
        ans++;//方案数+1
        return;
    &#125;
    for (int i = 0; i &lt; 4; i++)//枚举四个方向
    &#123;
        int newx = x + dx[i];
        int newy = y + dy[i];
        if (check(newx, newy))//该点合法
        &#123;
            visited[x][y] = true;//将(x,y)设置成已访问,修改现场
            dfs(newx, newy);//dfs下一个点
            visited[x][y] = false;//回溯,恢复现场
        &#125;
    &#125;
&#125;

int main()
&#123;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; T;
    cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; fx &gt;&gt; fy;
    while(T--)
    &#123;
        cin &gt;&gt; l &gt;&gt; r;
        map[l][r] = 1;
    &#125;
    dfs(sx, sy);//从起点开始搜索
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<blockquote>
<p>小伙伴们每道例题都要好好看一下AC代码噢，上面有很详细的注释。</p>
</blockquote>
<blockquote>
<p>这道题还可以优化下空间，可以只用maze数组来表示迷宫，同时记录迷宫内的某点是否访问过。具体见下面的代码。</p>
</blockquote>
<pre><code class="cpp">//空间优化
#include &lt;iostream&gt;
using namespace std;

const int N = 100;

int dx[4] = &#123;0, 0, -1, 1&#125;;
int dy[4] = &#123;1, -1, 0, 0&#125;;//方向数组
int n, m, T;
int ans;
int sx, sy, fx, fy, l, r;
//bool visited[N][N];
int map[N][N];//map[i][j] == 1表示是障碍
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
bool check(int x, int y)//判断某点是否可以访问
&#123;
    if (x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; n) return false;
    if (map[x][y] || map[x][y] == 3 ) return false;//该点是障碍点或已经访问过，不能访问
    //if (visited[x][y]) return false;
    return true;
&#125;

void dfs(int x, int y)
&#123;
    if (x == fx &amp;&amp; y == fy)
    &#123;
        ans++;
        return;
    &#125;
    for (int i = 0; i &lt; 4; i++)
    &#123;
        int newx = x + dx[i];
        int newy = y + dy[i];
        if (check(newx, newy))
        &#123;
            map[x][y] = 3;//标记成已访问
            dfs(newx, newy);
            //点(x,y)能访问说明它不是障碍点所以回溯要让map[x][y]=0
            //而不是map[x][y]=1
            map[x][y] = 0;
        &#125;
    &#125;
&#125;
int main()
&#123;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; T;
    cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; fx &gt;&gt; fy;
    while(T--)
    &#123;
        cin &gt;&gt; l &gt;&gt; r;
        map[l][r] = 1;
    &#125;
    dfs(sx, sy);
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<p><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/f0d98badf856489392bc3a7bfad24d98.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="2-01背包问题-DFS暴力搜索"><a href="#2-01背包问题-DFS暴力搜索" class="headerlink" title="2.01背包问题(DFS暴力搜索)"></a>2.01背包问题(DFS暴力搜索)</h3><p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/2/">题目链接</a><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/597a9a9e51c24576a62a7ad2d74e9b21.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16" alt="背包问题"><br><strong>题目分析</strong></p>
<blockquote>
<p>01背包问题是一个很经典的问题，它有多种解法。DFS是其中一种，在学习动态规划的时候还会提到它噢。</p>
</blockquote>
<p>第i件物品无非就是选和不选两种情况，在搜索的过程中DFS函数必须要记录当前处理的物品编号<code>index</code>，当前背包的容量<code>sumW</code>，当前的总价值<code>sumC</code>。</p>
<ul>
<li>当不选第<code>index</code>个物品时，那么<code>sumW</code>,<code>sumC</code>是不变的，接着处理第<code>index+1</code>个物品，也就是<code>DFS(index+1, sumW, sumC)</code>。</li>
<li>当选择第<code>index</code>个物品时，<code>sumW</code>变成<code>sumW+w[index]</code>，<code>sumC</code>变成<code>sumC+v[index]</code>，接着处理第<code>index+1</code>个物品，也就是<code>DFS(index+1, sumW+w[index],sumC+v[index])</code>。边界条件也就是把最后一件物品也处理完了，即<code>index=n</code>（注意默认index从0开始）。</li>
</ul>
<p>当一条分支结束了该干什么呢，很简单呀就是判断该分支最终满不满足总重量不大于背包容量。即<code>sumW&lt;=v</code>。满足的话我们就更新价值<code>maxvalue</code>，即<code>maxvalue=max(maxvalue,sumC)</code>。</p>
<p><strong>AC代码</strong></p>
<pre><code class="cpp">//01背包问题的dfs版本
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 10010;
int n, v, maxvalue;
int w[N], c[N];
//DFS维护三个参数，正在选第index个物品，当前的总体积，当前的总价值
void dfs(int index, int sumW, int sumC)
&#123;
    if (index == n)
    &#123;
        if (sumW &lt;= v)
        &#123;
            maxvalue = max(maxvalue, sumC);
        &#125;
        return;
    &#125;
    dfs(index + 1, sumW, sumC);//不选第index个物品
    dfs(index + 1, sumW + w[index], sumC + c[index]);//选第index个物品
&#125;

int main()
&#123;
    cin &gt;&gt; n &gt;&gt; v;
    for (int i = 0; i &lt; n; i++)
    &#123;
        cin &gt;&gt; w[i] &gt;&gt; c[i];
    &#125;
    dfs(0, 0, 0);//开始时对第1件物品进行选择，此时背包重量0价值也是0
    cout &lt;&lt; maxvalue &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<blockquote>
<p>当然了01背包问题如果用<code>DFS</code>来解决的话，当数据比较大时，是不能<code>AC</code>的。这道题会超出时间限制。即便经过剪枝也是无能为力的。</p>
</blockquote>
<p><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/b9204460d99f411dae0c590f14f4196a.png" alt="在这里插入图片描述"></p>
<h3 id="3-回溯——-USACO1-5-八皇后-Checker-Challenge"><a href="#3-回溯——-USACO1-5-八皇后-Checker-Challenge" class="headerlink" title="3.回溯——[USACO1.5]八皇后 Checker Challenge"></a>3.回溯——[USACO1.5]八皇后 Checker Challenge</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1219">题目链接</a><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/e0392de0426f4359962c51f77cf5484f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/d9ae3a9ad53f44418de0d2a2f06c8c4b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>题目分析</strong></p>
<blockquote>
<p>八皇后问题是学习回溯很经典的例题，这道题是八皇后问题的扩展，N皇后问题。也就是棋盘的大小是任意的。</p>
</blockquote>
<p>这道题<code>DFS</code>的思路还是比较清晰的，每行有且只有一个棋子，那么<code>DFS</code>可以记录下当前处理的是第几行的棋子。假设当前处理的是第<code>i</code>行的棋子，那么要枚举处在该行的棋子位置，判断哪个是合法的。<br>什么样的位置算是合法的呢，这个位置的列还有左对角线，右对角线位置都不能有棋子。那么又该如何表示这些位置呢？我们采用一维数组来分别表示列，左对角线，右对角线。列很好表示就是<code>b[j]</code>，左对角线我们可以发现行减去列的绝对值是恒定的，即<code>c[i-j+n]</code>,右对角线行加列是恒定的。即<code>d[i+j]</code>。</p>
<blockquote>
<p>小伙伴们可以自己画画图看一看噢~</p>
</blockquote>
<p>当某位置放置了棋子，那么就将和它同列同对角线的位置都取为1，即<code>b[j]=1</code>,<code>c[i-j+n]=1</code>,<code>d[i+j]=1</code>。</p>
<p><strong>AC代码</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;

int a[100], b[100], c[100], d[100];//a[]储存解b列c左斜d右斜
int n;//棋盘大小
int ans;

bool check(int i, int j)//检查(i,j)是否合法
&#123;
    if (!b[j] &amp;&amp; !c[j - i + n] &amp;&amp; !d[j + i]) return true;//b[j],c[i-j+n],d[i+j]为0说明该点可以放置棋子。
    return false;
&#125;

void dfs(int i)//dfs第i行棋子
&#123;   //边界条件
    if (i &gt; n)//dfs完所有的棋子
    &#123;
         ans++;
        if (ans &lt;= 3)//只要前三个解
        &#123;
            for (int i = 1; i &lt;= n; i++)//输出解
            &#123;
                cout &lt;&lt; a[i] &lt;&lt; &#39; &#39;;
                
            &#125;
            cout &lt;&lt; endl;  
        &#125;
        return;     
    &#125;
    
        for (int j = 1; j &lt;= n; j++)//枚举一行的所有位置
        &#123;	//(i,j)点满足放棋子的条件，我们就把棋子放在(i,j)点
            if (check(i, j))
            &#123;
                a[i] = j;//把满足解的列号存在a[i]中
                b[j] = 1;//修改现场
                c[ j - i + n] = 1;
                d[j + i] = 1;
                dfs(i + 1);//处理下一行的棋子
                b[j] = 0;//回溯，恢复现场
                c[j - i + n] = 0;
                d[j + i] = 0;
            &#125;
        &#125;
&#125;
int main()
&#123;
    cin &gt;&gt; n;
    dfs(1);
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<p><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/c37e19018b064ee88491028af5bec829.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="4-递归实现排列型枚举"><a href="#4-递归实现排列型枚举" class="headerlink" title="4.递归实现排列型枚举"></a>4.递归实现排列型枚举</h3><p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/96/">题目链接</a><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/93f1e3da7444452c827100778284df39.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>题目分析</strong></p>
<blockquote>
<p>DFS可以用来处理排列组合问题。</p>
</blockquote>
<p>对于全排列问题我们可以这样想，第1个位置可以放<code>1~n</code>任意一个数，第2个位置可以放除了放在第1个位置的数以外的任何一个数，以此类推。因此我们可以画出一个递归搜索树，用<code>map[]</code>来表示储存当前排列。<code>DFS</code>函数要记住当前处理的是第<code>index</code>个位置，从1到n进行遍历，看看这个数是否可以放在第<code>index</code>个位置，需要有一个判重数组<code>hashtable[x]</code>来记录<code>x</code>是否在排列里面。</p>
<p><strong>AC代码</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;

const int N = 11;
//map[N]储存当前的排列，hashtable[N]判断某个数是否在排列里
int map[N];
bool hashtable[N];面。
int n;

void dfs(int index)//当前填第index位置
&#123;
    if (index == n + 1)//已经处理完1~n个位置
    &#123;
        for (int i = 1; i &lt;= n; i++)//输出当前排列
        &#123;
            cout &lt;&lt; map[i] &lt;&lt; &#39; &#39;;
        &#125;
        cout &lt;&lt; endl;
        return;
    &#125;
    for (int i = 1; i &lt;= n; i++)//枚举1~n
    &#123;
        if (hashtable[i] == false)//当i这个数没有填在map中
        &#123;
            map[index] = i;//第index位置填入i这个数
            hashtable[i] = true;//记i在当前排列
            dfs(index + 1);//处理第index+1位置
            //处理完map[index]=i的子问题，恢复现场
            hashtable[i] = false;
            map[index] = 0;
        &#125;
    &#125;
&#125;
int main()
&#123;
    cin &gt;&gt; n;
    dfs(1);//从1这个数开始搜索
    return 0;
&#125;
</code></pre>
<p><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/de6462dec44d47daa0afa1023d8a0c89.png" alt="在这里插入图片描述"></p>
<h3 id="5-递归实现组合型枚举"><a href="#5-递归实现组合型枚举" class="headerlink" title="5.递归实现组合型枚举"></a>5.递归实现组合型枚举</h3><p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/95/">题目链接</a><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/e84e6dee11d64d5688a7e07c419aa54b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/36278db485514eff94f4487f54653173.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>题目分析</strong><br>组合和排列的最大区别就是组合不需要考虑顺序，也就是说<code>123</code>和<code>132</code>是一样的。<br>由于题目要求同一行的数必须按升序排序，因此可以让<code>DFS</code>函数记录当前处理的第<code>index</code>个位置，可以选的最小数<code>start</code>。</p>
<blockquote>
<p>虽然参数变成了两个，但是不需要判重数组了。</p>
</blockquote>
<p><code>DFS</code>的思路是这个样子的，假设当前处理的是第<code>index</code>个位置，这个位置可以放置<code>start~n</code>其中任意一个数。接着处理第<code>index+1</code>个位置，这个位置可以放置的最小数是前一位数的下一个数。即<code>i+1~n</code>。</p>
<p><strong>AC代码</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;

const int N = 30;

int map[N];//存储解
int n, m;
//dfs记录当前处理的第index个位置，可以选的最小数start
void dfs(int index, int start)
&#123;
    if (index &gt; m)//m个位置都处理完了
    &#123;
        for (int i = 1; i &lt;= m; i++)//输出方案
        &#123;
            cout &lt;&lt; map[i] &lt;&lt; &quot; &quot;;
        &#125;
        cout &lt;&lt; endl;
        return;
    &#125;
    //第index个位置可以选择start~n里面的数
    for (int i = start; i &lt;= n; i++)
    &#123;
        map[index] = i;
        //处理index+1位置，能选择的最小数是前面选择的数+1
        dfs(index + 1, i + 1);
        //处理完第index位置放置i这个数的子问题后回溯。
        map[index] = 0;
      
    &#125;
&#125;

int main()
&#123;
    cin &gt;&gt; n &gt;&gt; m;
    dfs(1, 1);
    return 0;
&#125;
</code></pre>
<p><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/353f2858c0d24affbfb1c9307427a79c.png" alt="在这里插入图片描述"></p>
<hr>
<h2 id="四、剪枝思想"><a href="#四、剪枝思想" class="headerlink" title="四、剪枝思想"></a>四、剪枝思想</h2><p>前面也提到过剪枝的概念，现在详细说下剪枝这种东西。我们知道<code>DFS</code>时间复杂度是很高的，如果不进行一些优化的话，在数据很大的情况下很容易就爆<code>TLE</code>。这个时候我们就可以用剪枝这种东西来优化啦~<br>在进行<code>DFS</code>的过程中对某条可以确定不存在解的分支采用直接剪短的策略。这样会大大降低计算量。一个搜索树剪掉一些分支就形象的叫它剪枝了。<br>&#x3D;&#x3D;剪枝一般都是利用题目的限制条件来确定哪些分支是不可能存在解的。&#x3D;&#x3D;</p>
<hr>
<h2 id="五、剪枝思想在DFS中的应用"><a href="#五、剪枝思想在DFS中的应用" class="headerlink" title="五、剪枝思想在DFS中的应用"></a>五、剪枝思想在DFS中的应用</h2><p>小伙伴们来回忆下01背包问题，我们是在选择完所有物品后才进行判断，看看背包总体积是否超过背包容量。是不是可以在选择的过程中就加入这一判断，这样就可以减少很多的计算量。当选第<code>index</code>件物品时，如果选上它那么背包的总体积就超出背包容量，我们一定不能选了。此时选第<code>index</code>件物品的分支就不可能存在解，直接剪掉。</p>
<pre><code class="cpp">//DFS维护三个参数，正在选第index个物品，当前的总体积，当前的总价值
void dfs(int index, int sumW, int sumC)
&#123;
    if (index == n)//选择完所有的物品，最终的sumW一定不大于v
    &#123;
        maxvalue = max(maxvalue, sumC);
        return;
    &#125;
    dfs(index + 1, sumW, sumC);//不选第index个物品
    if (sum + w[index] &lt;= v)//剪枝
    &#123;   //选第index个物品
        dfs(index + 1, sumW + w[index], sumC + c[index]);
    &#125; 
&#125;
</code></pre>
<p>小伙伴们再来回忆下前面的组合型枚举问题，我们也可以用到剪枝来优化。可以看出要是剩下的数全都用上也满足不了一共m个数的要求，那么我们直接可以结束这个分支了。即<code>n - start + index &lt; m</code>。</p>
<pre><code class="cpp">void dfs(int index, int start)
&#123;
    if (n - start + index &lt; m) return;//剪枝
    if (index &gt; m)//m个位置都处理完了
    &#123;
        for (int i = 1; i &lt;= m; i++)//输出方案
        &#123;
            cout &lt;&lt; map[i] &lt;&lt; &quot; &quot;;
        &#125;
        cout &lt;&lt; endl;
        return;
    &#125;
    //第index个位置可以选择start~n里面的数
    for (int i = start; i &lt;= n; i++)
    &#123;
        map[index] = i;
        //处理index+1位置，能选择的最小数是前面选择的数+1
        dfs(index + 1, i + 1);
        //处理完第index位置放置i这个数的子问题后回溯。
        map[index] = 0;
      
    &#125;
&#125;
</code></pre>
<blockquote>
<p>通过下表我们能看出剪枝之后的运行速度确实快了不少。<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/3f184725aed44b37bdb9b40924995a4b.png" alt="在这里插入图片描述"></p>
</blockquote>
<hr>
<h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><blockquote>
<p>想到啥就说啥了，给备战蓝桥杯的小伙伴们提些建议。</p>
</blockquote>
<p>我不推荐大家去<code>leetcode</code>上刷题，因为<code>leetcode</code>的形式和蓝桥杯是不太一样的。力扣只需要写函数，输入输出已经内置好了。蓝桥杯的输入输出是需要自己写的。另外呢力扣主要是面向找工作的，题目是面试用的，不是专门打比赛的。因此题目不太适合蓝桥杯竞赛。当然了里面的题目还是很经典的，专门学某一算法是可以刷力扣的。我给大家推荐几个适合的网站还有书籍。</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/">ACwing网站</a><br><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/">洛谷</a><br><a target="_blank" rel="noopener" href="https://www.dotcpp.com/oj/train/">C语言网蓝桥杯题库</a><br><a target="_blank" rel="noopener" href="http://lx.lanqiao.cn/problemsets.page">蓝桥杯练习系统</a><br><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/?sort=students_count&category_id=3">蓝桥杯官网题库</a><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/da7e876c11b741df8c7d3d5b71ab38f8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/b811a601fe264db3988a7eca92347a1f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/df58c6e5577e47d5a9fd70ca73d21e06.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/a799d7696df843f3b8a57695348148cc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<blockquote>
<p>这几个网站和书是我一直在用的，真心推荐给大家~</p>
</blockquote>
<p>美好的时光总是短暂的，又到了说再见的时候啦~一键三连支持一下吧！<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/174d4b7d8830426085d94f82fa74bd55.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_15,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/15/%E7%AE%97%E6%B3%95/" data-id="clk3tkoo200007ks9hp2j5l53" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/" rel="tag">蓝桥杯</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 才疏学浅的小熊<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>




<script src="/js/script.js"></script>




  </div>

        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body>
</html>