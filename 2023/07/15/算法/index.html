<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>算法——搜索专题 | 考研er的精神所</title><meta name="author" content="才疏学浅的小熊"><meta name="copyright" content="才疏学浅的小熊"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="写在前面蓝桥杯省赛将在4月初举行，距离比赛也就剩一个多月的时间。为了提高自己的编程能力，在比赛中取得比较👌的成绩。接下来的一个多月我会在博客中更新蓝桥杯的学习。争取在考前将一些重要的算法过一遍。蓝桥杯常考的算法我整理到了一张思维导图里面，小伙伴可以看一下噢。  这张蓝桥杯思维导图可能不太全面，以后会经常补充的。。  我是这样想滴，我会对常考的算法做个专题总结，分专题来讲。文章更新的速度呢取决于">
<meta property="og:type" content="article">
<meta property="og:title" content="算法——搜索专题">
<meta property="og:url" content="http://example.com/2023/07/15/%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="考研er的精神所">
<meta property="og:description" content="写在前面蓝桥杯省赛将在4月初举行，距离比赛也就剩一个多月的时间。为了提高自己的编程能力，在比赛中取得比较👌的成绩。接下来的一个多月我会在博客中更新蓝桥杯的学习。争取在考前将一些重要的算法过一遍。蓝桥杯常考的算法我整理到了一张思维导图里面，小伙伴可以看一下噢。  这张蓝桥杯思维导图可能不太全面，以后会经常补充的。。  我是这样想滴，我会对常考的算法做个专题总结，分专题来讲。文章更新的速度呢取决于">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/avatar.png">
<meta property="article:published_time" content="2023-07-15T09:25:19.000Z">
<meta property="article:modified_time" content="2023-07-15T09:55:54.661Z">
<meta property="article:author" content="才疏学浅的小熊">
<meta property="article:tag" content="蓝桥杯">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/07/15/%E7%AE%97%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法——搜索专题',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-07-15 17:55:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/background.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/loading.gif" data-original="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="考研er的精神所"></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">算法——搜索专题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-15T09:25:19.000Z" title="发表于 2023-07-15 17:25:19">2023-07-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-07-15T09:55:54.661Z" title="更新于 2023-07-15 17:55:54">2023-07-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法——搜索专题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><p><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/acdd5d863020486a920cbece48dbe12d.gif#pic_center" alt="在这里插入图片描述"></p>
<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>蓝桥杯省赛将在4月初举行，距离比赛也就剩一个多月的时间。为了提高自己的编程能力，在比赛中取得比较👌的成绩。接下来的一个多月我会在博客中更新蓝桥杯的学习。争取在考前将一些重要的算法过一遍。<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/89a67bbb0969467587a73d313071f5bb.gif#pic_center" alt="在这里插入图片描述"><br>蓝桥杯常考的算法我整理到了一张思维导图里面，小伙伴可以看一下噢。<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/a63bde7e7247449f9b3b780d4ddd2db7.bmp?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>这张蓝桥杯思维导图可能不太全面，以后会经常补充的。。</p>
</blockquote>
<p>我是这样想滴，我会对常考的算法做个专题总结，分专题来讲。文章更新的速度呢取决于我刷题的速度啦！ 因为每写一个专题必然要写运用到这种算法的题目啦~~~鲁迅先生说过~~  “只讲解算法思想，不实际运用就是在耍流氓”。写蓝桥杯文章的过程是这个样子的，先确定要写哪个专题，然后呢大量刷题，模板题啦，经典题啦，最最重要的是历届的蓝桥杯真题啦。刷完之后呢做总结理清这种算法的基本思路，最后就形成了一篇蓝桥杯备考文章啦。当然文章是要时常更改补充的，因为在刷题的过程中可能对某些算法思想有了新的感悟~也要参加蓝桥杯的小伙伴们可以一起期待噢，关注我一定不会让你失望的。噢还有我参加的是C++组所以呢我写的题解也是C++的。</p>
<blockquote>
<p>我的CSDN博客 <a target="_blank" rel="noopener" href="https://blog.csdn.net/ccevv/">https://blog.csdn.net/ccevv/</a></p>
</blockquote>
<hr>
<p>好啦接下来进入正题。<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/caa97b1a74dc41959dd23b2ef973a6e6.png#pic_center" alt="在这里插入图片描述"><br>我们知道蓝桥杯俗称暴力杯，搜索在蓝桥杯中是最最基本的算法思想。学会DFS和BFS是在蓝桥杯比赛中取得好成绩的基础。我会从这几个方面入手，给小伙伴们详细讲解搜索专题。<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/7d631a7e65bb430c9c1015d59f642b96.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>本篇的内容主要有以下几个方面噢，小伙伴们可以有个大致了解。</p>
<blockquote>
<p>DFS基本思想(DFS+回溯）<br>深度优先搜索模板<br>DFS例题<br>剪枝思想<br>剪枝思想在DFS中的应用</p>
</blockquote>
<hr>
<p>@[TOC]</p>
<hr>
<h2 id="一、深度优先搜索-DFS-回溯"><a href="#一、深度优先搜索-DFS-回溯" class="headerlink" title="一、深度优先搜索(DFS)+回溯"></a>一、深度优先搜索(DFS)+回溯</h2><p><code>DFS</code>是一种搜索的策略，简单来说就是一条路走到黑。当走到尽头之后就回退到上一个结点，继续一条路走到黑。回退的过程就叫做<strong>回溯</strong>。<br><code>DFS</code>一般采用<strong>递归</strong>的方式实现。</p>
<blockquote>
<p>对递归的详细讲解会在以后出一个独立的专题，小伙伴们可以期待一下噢！</p>
</blockquote>
<p><code>DFS</code>可以用一个递归搜索树来形象描述，那这棵树长什么样子呢，小伙伴们继续往下看。<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/b46f5fe9bde34fbd907b714c6ea1284c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><br>事实上对所有的合法<code>DFS</code>求解过程都可以把它画成树的形式，死胡同就相当于叶子结点。分岔口就相当于非叶子结点。</p>
<blockquote>
<p>对某个DFS类型的题目，不妨把一些状态作为树的结点，问题就变得很直观了。</p>
</blockquote>
<p><code>DFS</code>搜索的顺序是A-B-D-E-C-F。从结点A出发，它有两条路可以走，我们选择最左边那一条，到达结点B，结点B有两个分支，选择最左边那个，到达结点D。结点D没有路可走了也就是到达死胡同了，返回上一个结点B，也就是回溯的过程。B还有一条路可走，到达结点E。同理结点E回溯到结点B，结点B没有分支了，回溯到上一个结点A，结点A还有一个分支可以走，到达结点C,结点C有一个分支到达结点F，结点F是死胡同。至此所有的结点都访问了，搜索结束。</p>
<blockquote>
<p>其实DFS的搜索顺序和树的先序遍历是一样的。树的先序遍历就是根左右。</p>
</blockquote>
<p>从递归树我们就能看出<code>DFS</code>的时间复杂度是很高的，是$O(2^n)$。所以我们常说暴力搜索嘛，就是因为它时间复杂度太高了，当数据很大时很容易就<code>TLE(</code>超时)的。同时我们还能看出<code>DFS</code>会走遍所有的路径，并且走到死胡同就代表一条完整的路径形成。因此&#x3D;&#x3D;深度优先搜索是一种枚举所有路径，遍历所有情况的搜索策略&#x3D;&#x3D;。</p>
<hr>
<h2 id="二、DFS模板"><a href="#二、DFS模板" class="headerlink" title="二、DFS模板"></a>二、DFS模板</h2><blockquote>
<p>在备战蓝桥杯的过程中记住一些算法模板还是非常重要滴。</p>
</blockquote>
<pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;
bool check()
&#123;
    ...
&#125;
void dfs()
&#123;
    if (满足边界条件)
    &#123;
        
        return;
    &#125;
    for (int i = 0; i &lt; 可扩展的路径数; i++)
    &#123;
        if (check())
        &#123;
            修改现场;
            dfs(下一种情况);
            还原现场;
        &#125;
    &#125;
&#125;	
</code></pre>
<blockquote>
<p>模板不是固定不变的，我们要根据题目灵活地运用它。</p>
</blockquote>
<hr>
<h2 id="三、DFS经典例题"><a href="#三、DFS经典例题" class="headerlink" title="三、DFS经典例题"></a>三、DFS经典例题</h2><h3 id="1-模板题——迷宫问题"><a href="#1-模板题——迷宫问题" class="headerlink" title="1.模板题——迷宫问题"></a>1.模板题——迷宫问题</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1605">题目链接</a><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/76bfafbf85ae400bbf980124689c8b74.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>题目分析</strong></p>
<blockquote>
<p>迷宫问题是拿来练习DFS与BFS很经典的题目。迷宫问题有很多种问法，比如迷宫从起点到终点有没有路径，有几条，最短路径是多少。</p>
</blockquote>
<p>求从起点到终点的方案数显而易见也是要用<code>DFS</code>，遍历所有的情况。我们要考虑这样一个问题，迷宫里的某点<code>(x,y)</code>是否要被访问呢。当这点是障碍物肯定不能访问，该点不在迷宫里面也不能访问，该点访问过了那就不能访问了。(题目中有每个方格最多经过一次)。因此我们需要一个<code>check()</code>函数来判断某一点是否合法。合法我们就去访问该点。</p>
<blockquote>
<p>其实这个过程就是一个剪枝的过程，根据题目条件限制，剪掉一些不可能存在解的分支。</p>
</blockquote>
<p>另外我们该如何知道某点是障碍点呢，可以设置一个map数组来表示该迷宫。</p>
<ul>
<li>当<code>map[x][y]==1</code>时表示该点是障碍点 </li>
<li><code>map[x][y]==0</code>表示该点是正常点</li>
</ul>
<p><strong>AC代码</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;

const int N = 100;

int dx[4] = &#123;0, 0, -1, 1&#125;;
int dy[4] = &#123;1, -1, 0, 0&#125;;//方向数组技巧
int n, m, T;//n行m列T障碍总数
int ans;//记录方案总数
int sx, sy, fx, fy, l, r;//起点坐标(sx,sy)终点坐标(fx,fy)障碍点坐标(l,r)
bool visited[N][N];//记录某点是否被访问过
int map[N][N];//map[i][j] == 1表示是障碍

bool check(int x, int y)//check某点是否合法
&#123;
    if (x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; m) return false;//该点出界不合法
    if (map[x][y]) return false;//该点是障碍点不合法
    if (visited[x][y]) return false;//该点被访问过不合法
    return true;//其他情况访问合法
&#125;

void dfs(int x, int y)//dfs维护点的坐标参数
&#123;
    if (x == fx &amp;&amp; y == fy)//满足边界条件，到达终点
    &#123;
        ans++;//方案数+1
        return;
    &#125;
    for (int i = 0; i &lt; 4; i++)//枚举四个方向
    &#123;
        int newx = x + dx[i];
        int newy = y + dy[i];
        if (check(newx, newy))//该点合法
        &#123;
            visited[x][y] = true;//将(x,y)设置成已访问,修改现场
            dfs(newx, newy);//dfs下一个点
            visited[x][y] = false;//回溯,恢复现场
        &#125;
    &#125;
&#125;

int main()
&#123;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; T;
    cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; fx &gt;&gt; fy;
    while(T--)
    &#123;
        cin &gt;&gt; l &gt;&gt; r;
        map[l][r] = 1;
    &#125;
    dfs(sx, sy);//从起点开始搜索
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<blockquote>
<p>小伙伴们每道例题都要好好看一下AC代码噢，上面有很详细的注释。</p>
</blockquote>
<blockquote>
<p>这道题还可以优化下空间，可以只用maze数组来表示迷宫，同时记录迷宫内的某点是否访问过。具体见下面的代码。</p>
</blockquote>
<pre><code class="cpp">//空间优化
#include &lt;iostream&gt;
using namespace std;

const int N = 100;

int dx[4] = &#123;0, 0, -1, 1&#125;;
int dy[4] = &#123;1, -1, 0, 0&#125;;//方向数组
int n, m, T;
int ans;
int sx, sy, fx, fy, l, r;
//bool visited[N][N];
int map[N][N];//map[i][j] == 1表示是障碍
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
bool check(int x, int y)//判断某点是否可以访问
&#123;
    if (x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; n) return false;
    if (map[x][y] || map[x][y] == 3 ) return false;//该点是障碍点或已经访问过，不能访问
    //if (visited[x][y]) return false;
    return true;
&#125;

void dfs(int x, int y)
&#123;
    if (x == fx &amp;&amp; y == fy)
    &#123;
        ans++;
        return;
    &#125;
    for (int i = 0; i &lt; 4; i++)
    &#123;
        int newx = x + dx[i];
        int newy = y + dy[i];
        if (check(newx, newy))
        &#123;
            map[x][y] = 3;//标记成已访问
            dfs(newx, newy);
            //点(x,y)能访问说明它不是障碍点所以回溯要让map[x][y]=0
            //而不是map[x][y]=1
            map[x][y] = 0;
        &#125;
    &#125;
&#125;
int main()
&#123;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; T;
    cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; fx &gt;&gt; fy;
    while(T--)
    &#123;
        cin &gt;&gt; l &gt;&gt; r;
        map[l][r] = 1;
    &#125;
    dfs(sx, sy);
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<p><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/f0d98badf856489392bc3a7bfad24d98.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="2-01背包问题-DFS暴力搜索"><a href="#2-01背包问题-DFS暴力搜索" class="headerlink" title="2.01背包问题(DFS暴力搜索)"></a>2.01背包问题(DFS暴力搜索)</h3><p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/2/">题目链接</a><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/597a9a9e51c24576a62a7ad2d74e9b21.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16" alt="背包问题"><br><strong>题目分析</strong></p>
<blockquote>
<p>01背包问题是一个很经典的问题，它有多种解法。DFS是其中一种，在学习动态规划的时候还会提到它噢。</p>
</blockquote>
<p>第i件物品无非就是选和不选两种情况，在搜索的过程中DFS函数必须要记录当前处理的物品编号<code>index</code>，当前背包的容量<code>sumW</code>，当前的总价值<code>sumC</code>。</p>
<ul>
<li>当不选第<code>index</code>个物品时，那么<code>sumW</code>,<code>sumC</code>是不变的，接着处理第<code>index+1</code>个物品，也就是<code>DFS(index+1, sumW, sumC)</code>。</li>
<li>当选择第<code>index</code>个物品时，<code>sumW</code>变成<code>sumW+w[index]</code>，<code>sumC</code>变成<code>sumC+v[index]</code>，接着处理第<code>index+1</code>个物品，也就是<code>DFS(index+1, sumW+w[index],sumC+v[index])</code>。边界条件也就是把最后一件物品也处理完了，即<code>index=n</code>（注意默认index从0开始）。</li>
</ul>
<p>当一条分支结束了该干什么呢，很简单呀就是判断该分支最终满不满足总重量不大于背包容量。即<code>sumW&lt;=v</code>。满足的话我们就更新价值<code>maxvalue</code>，即<code>maxvalue=max(maxvalue,sumC)</code>。</p>
<p><strong>AC代码</strong></p>
<pre><code class="cpp">//01背包问题的dfs版本
#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

const int N = 10010;
int n, v, maxvalue;
int w[N], c[N];
//DFS维护三个参数，正在选第index个物品，当前的总体积，当前的总价值
void dfs(int index, int sumW, int sumC)
&#123;
    if (index == n)
    &#123;
        if (sumW &lt;= v)
        &#123;
            maxvalue = max(maxvalue, sumC);
        &#125;
        return;
    &#125;
    dfs(index + 1, sumW, sumC);//不选第index个物品
    dfs(index + 1, sumW + w[index], sumC + c[index]);//选第index个物品
&#125;

int main()
&#123;
    cin &gt;&gt; n &gt;&gt; v;
    for (int i = 0; i &lt; n; i++)
    &#123;
        cin &gt;&gt; w[i] &gt;&gt; c[i];
    &#125;
    dfs(0, 0, 0);//开始时对第1件物品进行选择，此时背包重量0价值也是0
    cout &lt;&lt; maxvalue &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<blockquote>
<p>当然了01背包问题如果用<code>DFS</code>来解决的话，当数据比较大时，是不能<code>AC</code>的。这道题会超出时间限制。即便经过剪枝也是无能为力的。</p>
</blockquote>
<p><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/b9204460d99f411dae0c590f14f4196a.png" alt="在这里插入图片描述"></p>
<h3 id="3-回溯——-USACO1-5-八皇后-Checker-Challenge"><a href="#3-回溯——-USACO1-5-八皇后-Checker-Challenge" class="headerlink" title="3.回溯——[USACO1.5]八皇后 Checker Challenge"></a>3.回溯——[USACO1.5]八皇后 Checker Challenge</h3><p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1219">题目链接</a><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/e0392de0426f4359962c51f77cf5484f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/d9ae3a9ad53f44418de0d2a2f06c8c4b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>题目分析</strong></p>
<blockquote>
<p>八皇后问题是学习回溯很经典的例题，这道题是八皇后问题的扩展，N皇后问题。也就是棋盘的大小是任意的。</p>
</blockquote>
<p>这道题<code>DFS</code>的思路还是比较清晰的，每行有且只有一个棋子，那么<code>DFS</code>可以记录下当前处理的是第几行的棋子。假设当前处理的是第<code>i</code>行的棋子，那么要枚举处在该行的棋子位置，判断哪个是合法的。<br>什么样的位置算是合法的呢，这个位置的列还有左对角线，右对角线位置都不能有棋子。那么又该如何表示这些位置呢？我们采用一维数组来分别表示列，左对角线，右对角线。列很好表示就是<code>b[j]</code>，左对角线我们可以发现行减去列的绝对值是恒定的，即<code>c[i-j+n]</code>,右对角线行加列是恒定的。即<code>d[i+j]</code>。</p>
<blockquote>
<p>小伙伴们可以自己画画图看一看噢~</p>
</blockquote>
<p>当某位置放置了棋子，那么就将和它同列同对角线的位置都取为1，即<code>b[j]=1</code>,<code>c[i-j+n]=1</code>,<code>d[i+j]=1</code>。</p>
<p><strong>AC代码</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;

int a[100], b[100], c[100], d[100];//a[]储存解b列c左斜d右斜
int n;//棋盘大小
int ans;

bool check(int i, int j)//检查(i,j)是否合法
&#123;
    if (!b[j] &amp;&amp; !c[j - i + n] &amp;&amp; !d[j + i]) return true;//b[j],c[i-j+n],d[i+j]为0说明该点可以放置棋子。
    return false;
&#125;

void dfs(int i)//dfs第i行棋子
&#123;   //边界条件
    if (i &gt; n)//dfs完所有的棋子
    &#123;
         ans++;
        if (ans &lt;= 3)//只要前三个解
        &#123;
            for (int i = 1; i &lt;= n; i++)//输出解
            &#123;
                cout &lt;&lt; a[i] &lt;&lt; &#39; &#39;;
                
            &#125;
            cout &lt;&lt; endl;  
        &#125;
        return;     
    &#125;
    
        for (int j = 1; j &lt;= n; j++)//枚举一行的所有位置
        &#123;	//(i,j)点满足放棋子的条件，我们就把棋子放在(i,j)点
            if (check(i, j))
            &#123;
                a[i] = j;//把满足解的列号存在a[i]中
                b[j] = 1;//修改现场
                c[ j - i + n] = 1;
                d[j + i] = 1;
                dfs(i + 1);//处理下一行的棋子
                b[j] = 0;//回溯，恢复现场
                c[j - i + n] = 0;
                d[j + i] = 0;
            &#125;
        &#125;
&#125;
int main()
&#123;
    cin &gt;&gt; n;
    dfs(1);
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
&#125;
</code></pre>
<p><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/c37e19018b064ee88491028af5bec829.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="4-递归实现排列型枚举"><a href="#4-递归实现排列型枚举" class="headerlink" title="4.递归实现排列型枚举"></a>4.递归实现排列型枚举</h3><p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/96/">题目链接</a><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/93f1e3da7444452c827100778284df39.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>题目分析</strong></p>
<blockquote>
<p>DFS可以用来处理排列组合问题。</p>
</blockquote>
<p>对于全排列问题我们可以这样想，第1个位置可以放<code>1~n</code>任意一个数，第2个位置可以放除了放在第1个位置的数以外的任何一个数，以此类推。因此我们可以画出一个递归搜索树，用<code>map[]</code>来表示储存当前排列。<code>DFS</code>函数要记住当前处理的是第<code>index</code>个位置，从1到n进行遍历，看看这个数是否可以放在第<code>index</code>个位置，需要有一个判重数组<code>hashtable[x]</code>来记录<code>x</code>是否在排列里面。</p>
<p><strong>AC代码</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;

const int N = 11;
//map[N]储存当前的排列，hashtable[N]判断某个数是否在排列里
int map[N];
bool hashtable[N];面。
int n;

void dfs(int index)//当前填第index位置
&#123;
    if (index == n + 1)//已经处理完1~n个位置
    &#123;
        for (int i = 1; i &lt;= n; i++)//输出当前排列
        &#123;
            cout &lt;&lt; map[i] &lt;&lt; &#39; &#39;;
        &#125;
        cout &lt;&lt; endl;
        return;
    &#125;
    for (int i = 1; i &lt;= n; i++)//枚举1~n
    &#123;
        if (hashtable[i] == false)//当i这个数没有填在map中
        &#123;
            map[index] = i;//第index位置填入i这个数
            hashtable[i] = true;//记i在当前排列
            dfs(index + 1);//处理第index+1位置
            //处理完map[index]=i的子问题，恢复现场
            hashtable[i] = false;
            map[index] = 0;
        &#125;
    &#125;
&#125;
int main()
&#123;
    cin &gt;&gt; n;
    dfs(1);//从1这个数开始搜索
    return 0;
&#125;
</code></pre>
<p><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/de6462dec44d47daa0afa1023d8a0c89.png" alt="在这里插入图片描述"></p>
<h3 id="5-递归实现组合型枚举"><a href="#5-递归实现组合型枚举" class="headerlink" title="5.递归实现组合型枚举"></a>5.递归实现组合型枚举</h3><p><a target="_blank" rel="noopener" href="https://www.acwing.com/problem/content/95/">题目链接</a><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/e84e6dee11d64d5688a7e07c419aa54b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/36278db485514eff94f4487f54653173.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><strong>题目分析</strong><br>组合和排列的最大区别就是组合不需要考虑顺序，也就是说<code>123</code>和<code>132</code>是一样的。<br>由于题目要求同一行的数必须按升序排序，因此可以让<code>DFS</code>函数记录当前处理的第<code>index</code>个位置，可以选的最小数<code>start</code>。</p>
<blockquote>
<p>虽然参数变成了两个，但是不需要判重数组了。</p>
</blockquote>
<p><code>DFS</code>的思路是这个样子的，假设当前处理的是第<code>index</code>个位置，这个位置可以放置<code>start~n</code>其中任意一个数。接着处理第<code>index+1</code>个位置，这个位置可以放置的最小数是前一位数的下一个数。即<code>i+1~n</code>。</p>
<p><strong>AC代码</strong></p>
<pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;

const int N = 30;

int map[N];//存储解
int n, m;
//dfs记录当前处理的第index个位置，可以选的最小数start
void dfs(int index, int start)
&#123;
    if (index &gt; m)//m个位置都处理完了
    &#123;
        for (int i = 1; i &lt;= m; i++)//输出方案
        &#123;
            cout &lt;&lt; map[i] &lt;&lt; &quot; &quot;;
        &#125;
        cout &lt;&lt; endl;
        return;
    &#125;
    //第index个位置可以选择start~n里面的数
    for (int i = start; i &lt;= n; i++)
    &#123;
        map[index] = i;
        //处理index+1位置，能选择的最小数是前面选择的数+1
        dfs(index + 1, i + 1);
        //处理完第index位置放置i这个数的子问题后回溯。
        map[index] = 0;
      
    &#125;
&#125;

int main()
&#123;
    cin &gt;&gt; n &gt;&gt; m;
    dfs(1, 1);
    return 0;
&#125;
</code></pre>
<p><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/353f2858c0d24affbfb1c9307427a79c.png" alt="在这里插入图片描述"></p>
<hr>
<h2 id="四、剪枝思想"><a href="#四、剪枝思想" class="headerlink" title="四、剪枝思想"></a>四、剪枝思想</h2><p>前面也提到过剪枝的概念，现在详细说下剪枝这种东西。我们知道<code>DFS</code>时间复杂度是很高的，如果不进行一些优化的话，在数据很大的情况下很容易就爆<code>TLE</code>。这个时候我们就可以用剪枝这种东西来优化啦~<br>在进行<code>DFS</code>的过程中对某条可以确定不存在解的分支采用直接剪短的策略。这样会大大降低计算量。一个搜索树剪掉一些分支就形象的叫它剪枝了。<br>&#x3D;&#x3D;剪枝一般都是利用题目的限制条件来确定哪些分支是不可能存在解的。&#x3D;&#x3D;</p>
<hr>
<h2 id="五、剪枝思想在DFS中的应用"><a href="#五、剪枝思想在DFS中的应用" class="headerlink" title="五、剪枝思想在DFS中的应用"></a>五、剪枝思想在DFS中的应用</h2><p>小伙伴们来回忆下01背包问题，我们是在选择完所有物品后才进行判断，看看背包总体积是否超过背包容量。是不是可以在选择的过程中就加入这一判断，这样就可以减少很多的计算量。当选第<code>index</code>件物品时，如果选上它那么背包的总体积就超出背包容量，我们一定不能选了。此时选第<code>index</code>件物品的分支就不可能存在解，直接剪掉。</p>
<pre><code class="cpp">//DFS维护三个参数，正在选第index个物品，当前的总体积，当前的总价值
void dfs(int index, int sumW, int sumC)
&#123;
    if (index == n)//选择完所有的物品，最终的sumW一定不大于v
    &#123;
        maxvalue = max(maxvalue, sumC);
        return;
    &#125;
    dfs(index + 1, sumW, sumC);//不选第index个物品
    if (sum + w[index] &lt;= v)//剪枝
    &#123;   //选第index个物品
        dfs(index + 1, sumW + w[index], sumC + c[index]);
    &#125; 
&#125;
</code></pre>
<p>小伙伴们再来回忆下前面的组合型枚举问题，我们也可以用到剪枝来优化。可以看出要是剩下的数全都用上也满足不了一共m个数的要求，那么我们直接可以结束这个分支了。即<code>n - start + index &lt; m</code>。</p>
<pre><code class="cpp">void dfs(int index, int start)
&#123;
    if (n - start + index &lt; m) return;//剪枝
    if (index &gt; m)//m个位置都处理完了
    &#123;
        for (int i = 1; i &lt;= m; i++)//输出方案
        &#123;
            cout &lt;&lt; map[i] &lt;&lt; &quot; &quot;;
        &#125;
        cout &lt;&lt; endl;
        return;
    &#125;
    //第index个位置可以选择start~n里面的数
    for (int i = start; i &lt;= n; i++)
    &#123;
        map[index] = i;
        //处理index+1位置，能选择的最小数是前面选择的数+1
        dfs(index + 1, i + 1);
        //处理完第index位置放置i这个数的子问题后回溯。
        map[index] = 0;
      
    &#125;
&#125;
</code></pre>
<blockquote>
<p>通过下表我们能看出剪枝之后的运行速度确实快了不少。<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/3f184725aed44b37bdb9b40924995a4b.png" alt="在这里插入图片描述"></p>
</blockquote>
<hr>
<h1 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h1><blockquote>
<p>想到啥就说啥了，给备战蓝桥杯的小伙伴们提些建议。</p>
</blockquote>
<p>我不推荐大家去<code>leetcode</code>上刷题，因为<code>leetcode</code>的形式和蓝桥杯是不太一样的。力扣只需要写函数，输入输出已经内置好了。蓝桥杯的输入输出是需要自己写的。另外呢力扣主要是面向找工作的，题目是面试用的，不是专门打比赛的。因此题目不太适合蓝桥杯竞赛。当然了里面的题目还是很经典的，专门学某一算法是可以刷力扣的。我给大家推荐几个适合的网站还有书籍。</p>
<p><a target="_blank" rel="noopener" href="https://www.acwing.com/">ACwing网站</a><br><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/">洛谷</a><br><a target="_blank" rel="noopener" href="https://www.dotcpp.com/oj/train/">C语言网蓝桥杯题库</a><br><a target="_blank" rel="noopener" href="http://lx.lanqiao.cn/problemsets.page">蓝桥杯练习系统</a><br><a target="_blank" rel="noopener" href="https://www.lanqiao.cn/problems/?sort=students_count&category_id=3">蓝桥杯官网题库</a><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/da7e876c11b741df8c7d3d5b71ab38f8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_12,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/b811a601fe264db3988a7eca92347a1f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/df58c6e5577e47d5a9fd70ca73d21e06.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/a799d7696df843f3b8a57695348148cc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_11,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<blockquote>
<p>这几个网站和书是我一直在用的，真心推荐给大家~</p>
</blockquote>
<p>美好的时光总是短暂的，又到了说再见的时候啦~一键三连支持一下吧！<br><img src="/img/loading.gif" data-original="https://img-blog.csdnimg.cn/174d4b7d8830426085d94f82fa74bd55.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_15,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">才疏学浅的小熊</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/07/15/%E7%AE%97%E6%B3%95/">http://example.com/2023/07/15/算法/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">考研er的精神所</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/">蓝桥杯</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/loading.gif" data-original="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/07/15/%E5%A4%A7%E5%94%90%E6%9D%AF%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/" title="大唐杯经验分享"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">大唐杯经验分享</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">才疏学浅的小熊</div><div class="author-info__description">纸上得来终觉浅，觉知此事须躬行</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/xubenshan" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:xxxxxx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">等考研结束在继续美化网站</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="toc-text">写在前面</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-DFS-%E5%9B%9E%E6%BA%AF"><span class="toc-text">一、深度优先搜索(DFS)+回溯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81DFS%E6%A8%A1%E6%9D%BF"><span class="toc-text">二、DFS模板</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81DFS%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98"><span class="toc-text">三、DFS经典例题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A8%A1%E6%9D%BF%E9%A2%98%E2%80%94%E2%80%94%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98"><span class="toc-text">1.模板题——迷宫问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-DFS%E6%9A%B4%E5%8A%9B%E6%90%9C%E7%B4%A2"><span class="toc-text">2.01背包问题(DFS暴力搜索)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9B%9E%E6%BA%AF%E2%80%94%E2%80%94-USACO1-5-%E5%85%AB%E7%9A%87%E5%90%8E-Checker-Challenge"><span class="toc-text">3.回溯——[USACO1.5]八皇后 Checker Challenge</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E6%8E%92%E5%88%97%E5%9E%8B%E6%9E%9A%E4%B8%BE"><span class="toc-text">4.递归实现排列型枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0%E7%BB%84%E5%90%88%E5%9E%8B%E6%9E%9A%E4%B8%BE"><span class="toc-text">5.递归实现组合型枚举</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%89%AA%E6%9E%9D%E6%80%9D%E6%83%B3"><span class="toc-text">四、剪枝思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%89%AA%E6%9E%9D%E6%80%9D%E6%83%B3%E5%9C%A8DFS%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">五、剪枝思想在DFS中的应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E5%90%8E%E9%9D%A2"><span class="toc-text">写在后面</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/15/801%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%84%9F%E6%82%9F/" title="801通信原理复习感悟">801通信原理复习感悟</a><time datetime="2023-07-15T15:12:18.000Z" title="发表于 2023-07-15 23:12:18">2023-07-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/15/git/" title="Git的学习笔记">Git的学习笔记</a><time datetime="2023-07-15T15:12:18.000Z" title="发表于 2023-07-15 23:12:18">2023-07-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/15/post%E5%A4%8D%E4%B9%A0%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%E7%9A%84%E6%84%9F%E6%82%9F/" title="复习考研政治的感悟">复习考研政治的感悟</a><time datetime="2023-07-15T09:52:30.000Z" title="发表于 2023-07-15 17:52:30">2023-07-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/15/%E5%A4%A7%E5%94%90%E6%9D%AF%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/" title="大唐杯经验分享">大唐杯经验分享</a><time datetime="2023-07-15T09:25:19.000Z" title="发表于 2023-07-15 17:25:19">2023-07-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/15/%E7%AE%97%E6%B3%95/" title="算法——搜索专题">算法——搜索专题</a><time datetime="2023-07-15T09:25:19.000Z" title="发表于 2023-07-15 17:25:19">2023-07-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 才疏学浅的小熊</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a,i=c[o];e=function(){c=c.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(n=new Image,a=t.getAttribute("data-original"),n.onload=function(){t.src=a,t.removeAttribute("data-original"),e&&e()},t.src!==a&&(n.src=a))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this);</script></body></html>