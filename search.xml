<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>801通信原理复习感悟</title>
      <link href="/2023/07/15/801%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%84%9F%E6%82%9F/"/>
      <url>/2023/07/15/801%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E6%84%9F%E6%82%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="801通信原理复习"><a href="#801通信原理复习" class="headerlink" title="801通信原理复习"></a>801通信原理复习</h1><blockquote><p>复盘下我的复习进度和成果，存在的问题。并作相应的调整。</p></blockquote><h2 id="时间安排"><a href="#时间安排" class="headerlink" title="时间安排"></a>时间安排</h2><p>  本来是从三月份就开始学习通信原理的，但是没有坚持下来，直到七月份才完成基础知识的复习。在复习基础知识的这段时间，开始是一个小时，后来就延长到了两个小时学习时间。一般都是在下午复习专业课。复习完一遍基础知识，我对通原的框架有了个比较清晰的认知。但是对具体的细节把握并不好。但是问题不大，专业课就是要快速多遍复习，在做题中去理解知识点。这一点在后面的做题中能很好的感悟到。</p><p>  七月初完成一轮知识点后，就进入了第二轮复习，也就是做题阶段。这个过程细节是这样的，每天做前一天看视频讲解的题目，大约8到9个左右。然后再看10个左右的题目讲解。每天专业课的时间在2小时左右。按照这个进度大约可以在8月中旬完成第二轮复习。</p><h2 id="复盘"><a href="#复盘" class="headerlink" title="复盘"></a>复盘</h2><p>  通过做题发现，通原的难度并不是很大，我觉得好好学是完全没问题拿140+的。只要对它有信心，敢想敢做就可以。存在的一个问题就是有时候做题想不到怎么做，然后就直接去看答案，没有一个独立思考的过程。这点我觉得完全无可厚非。因为这些习题我们要做很多遍，现在的目的就是快速结束第二轮，进行第三轮强化。每天两个小时时间也是完全没问题的，可以完成每天的计划，也给了自己一个紧迫感。</p><h2 id="未来规划"><a href="#未来规划" class="headerlink" title="未来规划"></a>未来规划</h2><p>  暑假最好能看完第三轮强化的拓展篇视频，然后在九月份完成第三轮强化，为九月份末的模考做准备。完成第三轮强化后，就可以对做过的强化篇和拓展篇。十月份可以进行小题强化和理论篇的复习。十一月和十二月等到时候再说。</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><blockquote><p>以下是我的时间安排</p></blockquote><ul><li>7.08-7.11 结束第三章强化篇习题</li><li>7.11-7.16 结束第四章强化篇习题</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 考研感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的学习笔记</title>
      <link href="/2023/07/15/git/"/>
      <url>/2023/07/15/git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git学习笔记"><a href="#Git学习笔记" class="headerlink" title="Git学习笔记"></a><strong>Git学习笔记</strong></h1><blockquote><p>我学习Git的原因就是为了很方便的将本地代码上传到远程仓库，比如<code>gitee</code>，<code>GitHub</code>。</p></blockquote><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a><strong>版本控制</strong></h2><blockquote><p>学习Git前一定要了解什么是版本控制。</p></blockquote><p>所谓的版本控制其实就是一种管理文件，工程历史记录的一种技术。这种技术可以很方便的查看更改历史记录，恢复到以前的版本。版本控制常用于管理多人协同开发项目中。</p><p>常见的版本控制工具：</p><ul><li>Git</li><li>SVN</li><li>CVS</li><li>VSS</li><li>TFS</li><li>Visual studio Online</li></ul><p>版本控制的分类</p><ul><li>本地版本控制</li></ul><p>记录文件每次的更新，对每个版本做一个快照。</p><ul><li>集中版本控制</li></ul><p>所有的版本数据都存储在一个中央服务器上，用户从服务器上同步更新或上传自己的修改。</p><p>所有的数据都在一个服务器上，用户本地只有自己以前同步的版本，只有联网才能看到之前的版本。另外如果这个服务器损坏，就会丢失所有的数据，需要定期备份。SVN是集中版本控制的典型。</p><ul><li>分布式版本控制</li></ul><p>每个用户的电脑都是一个服务器，所有的版本信息都同步到本地的每个用户，这样就可以在本地查看所有的版本历史，离线在本地提交，只需联网的时候push到相应的服务器或其他用户那里。每个用户保存的都是所有的版本数据，因此不用担心出现因为服务器损坏，或者网络问题，而不能工作的情况。Git是分布式版本控制的典型。</p><h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a><strong>Git简介</strong></h2><blockquote><p>Git就是一个分布式版本控制工具。</p></blockquote><p>Git是由Linux之父Linus开发的。是目前世界上最先进的分布式版本控制系统。</p><p>Git是开源的，免费的，最初的Git是为辅助Linux内核开发的，来代替Bitkeeper来管理和维护代码。</p><h2 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a><strong>Git的安装</strong></h2><h3 id="Windows下Git的安装"><a href="#Windows下Git的安装" class="headerlink" title="Windows下Git的安装"></a>Windows下Git的安装</h3><p><a href="https://git-scm.com/downloads">Git下载官网</a></p><p>在Git官网下载可能会非常慢，还会出现打不开网页的现象。小伙伴们可以去淘宝镜像下载：<a href="http://npm.taobao.org/mirrors/git-for-windows/">http://npm.taobao.org/mirrors/git-for-windows/</a>  ，下载对应版本即可。</p><p>安装的过程中只要无脑下一步即可。</p><p>安装完成之后，在开始菜单中会有Git项。如下图：</p><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/image-20220731165152676.png" alt="image-20220731165152676" style="zoom: 80%;" /><p>简单说一下，<code>Git Bash</code>是类似<code>linux</code>的命令行；<code>Git CMD</code>是类似<code>window cmd</code>的命令行；<code>Git GUI</code>是图形化界面。</p><p>在日常使用中，我们一般只用<code>Git Bash</code>。</p><p>我自己下载的是<code>2.36.1</code>版本。通过<code>win+R</code>，打开运行，输入<code>cmd</code>。然后输入<code>git --version</code>，就可以查看对应的版本信息了。</p><p><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/image-20220731165743893.png" alt="image-20220731165743893"></p><h2 id="Git的环境配置"><a href="#Git的环境配置" class="headerlink" title="Git的环境配置"></a><strong>Git的环境配置</strong></h2><pre><code class="bash">git config --system --list# 查看系统配置git config --global --list# 查看本地配置</code></pre><p>使用Git前我们需要设置用户名和密码。</p><ul><li><p><code>git config --global user.name &quot;用户名&quot;</code></p></li><li><p><code>git config --global user.email &quot;邮箱&quot;</code></p></li></ul><p>设置完成后输入<code>git config --global --list</code>，就可以查看用户名和邮箱是否设置成功。</p><p><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/image-20220731182535086.png" alt="image-20220731182535086"></p><p>另外Git在安装过程中会自动的将环境添加到系统变量的path路径下。不用额外进行添加。</p><p><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/image-20220731182135209.png" alt="image-20220731182135209"></p><h2 id="Git基本理论"><a href="#Git基本理论" class="headerlink" title="Git基本理论"></a><strong>Git基本理论</strong></h2><h2 id="Git项目搭建"><a href="#Git项目搭建" class="headerlink" title="Git项目搭建"></a><strong>Git项目搭建</strong></h2><p>在工作盘新建一个名为<code>test</code>文件夹，进入文件夹内部，右键打开<code>git bash</code>。</p><p>输入<code>git init</code>，将这个文件夹初始化成<code>git</code>管理的文件夹。</p><p><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/image-20220731182959388.png" alt="image-20220731182959388"></p><p>我们会看到文件夹内部多了一个<code>.git</code>文件夹。</p><p>输入<code>touch test.txt</code>，在工作目录下创建了一个test文本。</p><p><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/image-20220731195654748.png" alt="image-20220731195654748"></p><p><code>git add test.txt</code>，将test文件添加到index暂存区；</p><p><code>git commit -m &quot;add test.txt&quot;</code> 将test文件提交到本地仓库；</p><p><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/image-20220731205156110.png" alt="image-20220731205156110"></p><p>至此，我们已经将创建的文件存储在本地仓库了，我们可以通过pull命令将本地仓库同步到远程仓库中。下面看具体的做法。</p><h3 id="使用Github"><a href="#使用Github" class="headerlink" title="使用Github"></a>使用Github</h3><p>首先你要有一个Github账户。没有注册的小伙伴们可以先去注册一下。</p><p>由于本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，因此我们要进行一些必要的配置。</p><p>创建SSH key。看一下用户目录下是否有.ssh文件夹，里面是否有<code>id_rsa</code>和 <code>id_rsa.pub</code>。没有的话就要执行下面的命令（之前没用过github或gitee的话一般是没有的）</p><pre><code class="bash"># 进入用户目录下的.ssh目录 C:\Users\86186\\.ssh# 生成ssh公钥 右键git bashssh-keygen -t tsa -C &quot;youremail@example.com&quot; //邮箱地址换成自己的</code></pre><p>然后一路回车，使用默认值即可。执行完成后，.ssh文件夹下面就出现<code>id_rsa</code>和 <code>id_rsa.pub</code>文件，第一个是私钥，不能告诉别人；第二个是公钥。</p><p><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/image-20220801215656790.png" alt="image-20220801215656790"></p><p>打开公钥文件，将里面的内容复制下来。</p><p>登录github，点击设置，找到”SSH and GPG keys” ，点击”New SSH key”。</p><p><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/image-20220801220445338.png" alt="image-20220801220445338"></p><p>将公钥内容复制到Key文本框中，title随便起个名字，点击<code>Add SSH key</code>。ssh key添加成功！</p><p>输入 <code>ssh -T git@github.com </code>   若出现<code>You&#39;ve successfully authenticated,but GithHub does not provide shell access</code>则证明已经连接上GitHub了。</p><p>接下来就该创建一个远程仓库了！</p><p>点击右上角的加号，新建仓库 <code>New repository</code> 。</p><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/image-20220731200551687.png" alt="image-20220731200551687" style="zoom:67%;" /><p>然后输入仓库名称，仓库描述，是否公开，最后创建仓库。</p><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/image-20220731204108694.png" alt="image-20220731204108694" style="zoom:67%;" /><p>github仓库就创建完成了，接下来我们要让远程仓库和本地仓库关联起来。</p><p>在test文件夹下运行命令 <code>git remote add origin git@github.com:xubenshan/test.git</code>。注意要将<code>xubenshan/test</code>换成你自己的用户名。否则你关联的就是我的远程库，你是无法将本地库推送上去的。</p><p><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/image-20220731204824909.png" alt="image-20220731204824909"></p><p>出现<code>unsafe repository</code>这种情况的话，运行git给你的解决方案即可。<code>git config --global --add safe.directory F:/test</code>。</p><p>再次运行 <code>git remote add origin git@github.com:xubenshan/test.git</code>。这样就将本地库同远程库关联起来了。</p><p>在GitHub官方文档里面，关联完成后，还要将当前分支<code>master</code>改成<code>main</code>。<code>master</code>可能跟黑人有关。对于我们来说改不改其实问题不大。我们就不改了，这样命令会少一些。</p><p>执行命令<code>git push -u origin master</code>。这样就可以将本地仓库上传到远程库里面了。其中<code>origin</code>是远程库的名字，<code>master</code>是本地仓库的当前分支。</p><p>需要注意的是第一次执行这个命令的时候需要加<code>-u</code>。Git会把本地的<code>master</code>分支内容推送到远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。直接执行<code>git push origin master</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/Snipaste_2022-07-31_21-31-53.jpg" alt="Snipaste_2022-07-31_21-31-53"></p><p>刷新<code>github</code>界面就能看到我们上传的test文件了·。</p><p>另外我们可以将GitHub里面的项目克隆到本地来。在GitHub上面新建一个仓库，这次我们勾选上<code>Add a README file</code>。仓库会自动创建一个<code>README.md</code>文件。</p><p><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/image-20220801070555082.png" alt="image-20220801070555082"></p><p>在本地e盘执行<code>git clone git@github.com:xubenshan/test.git</code>，注意这里的仓库名仍然要换成你自己的。</p><p><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/image-20220801071312130.png" alt="image-20220801071312130"></p><p>github上面的项目就克隆到了本地，我们会发现e盘多了个test文件夹。</p><pre><code class="bash"># 进入test文件夹cd test# 查看test文件夹下的内容ls# test文件夹下出现了一个README.md文件。# 我们就会发现远程库成功克隆到了本地！</code></pre><p>之后我们就可以将本地的文件通过<code>git add</code> <code>git commit</code>  <code>git push</code>命令上传到远程仓库。注意push的时候不是<code>master</code>而是<code>main</code>。这是因为clone的时候自动将本地的分支命名为<code>main</code>。</p><blockquote><p>Git支持多种协议，默认的<code>git://</code>使用ssh，但也可以使用<code>https</code>等其他协议。只不过<code>https</code>速度比较慢。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/image-20220801072319285.png" alt="image-20220801072319285"></p><blockquote><p>其他常用的git命令</p></blockquote><pre><code class="bash"># 查看远程库信息git remote -v# 删除远程库 （只是解除本地库与远程库的关系，不是物理上的删除远程库。要想真的删除远程库，必须在github上面操作）git remote rm &lt;name&gt;</code></pre><h3 id="使用gitee"><a href="#使用gitee" class="headerlink" title="使用gitee"></a>使用gitee</h3><p>先注册登录码云，完善个人的信息。</p><p>设置本机绑定ssh公钥，实现免密码登录。</p><pre><code class="bash"># 进入用户目录下的.ssh目录 C:\Users\86186\\.ssh# 生成ssh公钥ssh-keygen -t tsassh</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/Snipaste_2022-07-31_21-50-51.jpg" alt="Snipaste_2022-07-31_21-50-51"></p><p>生成完之后打开<code>id_rsa.pub</code>文件，将公钥粘贴到gitee里面。</p><p><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/image-20220731215659358.png" alt="image-20220731215659358"></p><p>添加成功！</p><p>创建仓库，和GitHub类似，这里就不再重复了。</p><p>然后我们在本地库使用命令<code>git remote add</code>把它和远程库关联起来。</p><p><code>git remote add origin git@gitee.com:xu-benshan/test.git</code>。</p><p>之后的操作就和GitHub如出一辙了。<code>git push -u origin master</code>。</p><h3 id="Git问题汇总"><a href="#Git问题汇总" class="headerlink" title="Git问题汇总"></a>Git问题汇总</h3><p>在push的过程中，出现<code>error: failed to push some refs to &#39;gitee.com:xu-benshan/test.git</code>。解决方案参考<a href="https://blog.csdn.net/m0_43599959/article/details/108934056?ops_request_misc=&request_id=&biz_id=102&utm_term=failed%20to%20push%20some%20refs%20to%20%27g&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-108934056.142%5Ev35%5Epc_rank_34&spm=1018.2226.3001.4187">博客</a></p><p><code>error: failed to push some refs to &#39;github.com:xubenshan/test.git</code></p><p>另一种原因：执行了<code>git branch -M main</code>，将<code>master</code>分支重命名为<code>main</code>。pull的时候要将<code>master</code>改成<code>main</code>。</p><p><code>git push -u origin main</code></p><p>在<code>push</code>的过程中出现下面情况：</p><p><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/image-20220817070550908.png" alt="image-20220817070550908"></p><p>说明远程库和你的本地库版本不一样，这时候要先将远程库<code>pull</code>到本地库，然后再<code>push</code>到远程库。</p><pre><code class="bash">git pull --rebase origin mastergit push origin master</code></pre><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/image-20220817071019403.png" alt="image-20220817071019403" style="zoom:80%;" /><h2 id="Git操作"><a href="#Git操作" class="headerlink" title="Git操作"></a><strong>Git操作</strong></h2><h3 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h3><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><h3 id="搭建git服务器"><a href="#搭建git服务器" class="headerlink" title="搭建git服务器"></a>搭建git服务器</h3><h2 id="使用vscode操作Git"><a href="#使用vscode操作Git" class="headerlink" title="使用vscode操作Git"></a><strong>使用vscode操作Git</strong></h2>]]></content>
      
      
      
        <tags>
            
            <tag> 技术学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复习考研政治的感悟</title>
      <link href="/2023/07/15/post%E5%A4%8D%E4%B9%A0%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%E7%9A%84%E6%84%9F%E6%82%9F/"/>
      <url>/2023/07/15/post%E5%A4%8D%E4%B9%A0%E8%80%83%E7%A0%94%E6%94%BF%E6%B2%BB%E7%9A%84%E6%84%9F%E6%82%9F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 考研感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/07/15/%E7%AE%97%E6%B3%95/"/>
      <url>/2023/07/15/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="搜索专题"><a href="#搜索专题" class="headerlink" title="搜索专题"></a>搜索专题</h1><p>[TOC]</p><h2 id="深度优先搜索-DFS-回溯"><a href="#深度优先搜索-DFS-回溯" class="headerlink" title="深度优先搜索(DFS)+回溯"></a>深度优先搜索(DFS)+回溯</h2><p><code>DFS</code>是一种搜索的策略，简单来说就是一条路走到黑。当走到尽头之后就回退到上一个结点，继续一条路走到黑。回退的过程就叫做<strong>回溯</strong>。<br><code>DFS</code>一般采用<strong>递归</strong>的方式实现。<span id="more"></span></p><blockquote><p>对递归的详细讲解会在以后出一个独立的专题，小伙伴们可以期待一下噢！</p><p><code>DFS</code>可以用一个递归搜索树来形象描述，那这棵树长什么样子呢，小伙伴们继续往下看。<br><img src="https://img-blog.csdnimg.cn/b46f5fe9bde34fbd907b714c6ea1284c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述" style="zoom: 33%;" /><br>事实上对所有的合法<code>DFS</code>求解过程都可以把它画成树的形式，死胡同就相当于叶子结点。分岔口就相当于非叶子结点。<br>对某个DFS类型的题目，不妨把一些状态作为树的结点，问题就变得很直观了。</p><p><code>DFS</code>搜索的顺序是A-B-D-E-C-F。从结点A出发，它有两条路可以走，我们选择最左边那一条，到达结点B，结点B有两个分支，选择最左边那个，到达结点D。结点D没有路可走了也就是到达死胡同了，返回上一个结点B，也就是回溯的过程。B还有一条路可走，到达结点E。同理结点E回溯到结点B，结点B没有分支了，回溯到上一个结点A，结点A还有一个分支可以走，到达结点C,结点C有一个分支到达结点F，结点F是死胡同。至此所有的结点都访问了，搜索结束。<br>其实DFS的搜索顺序和树的先序遍历是一样的。树的先序遍历就是根左右。</p></blockquote><p>从递归树我们就能看出<code>DFS</code>的时间复杂度是很高的，是$O(2^n)$。所以我们常说暴力搜索嘛，就是因为它时间复杂度太高了，当数据很大时很容易就<code>TLE(</code>超时)的。同时我们还能看出<code>DFS</code>会走遍所有的路径，并且走到死胡同就代表一条完整的路径形成。因此深度优先搜索是一种枚举所有路径，遍历所有情况的搜索策略。</p><hr><h2 id="DFS模板"><a href="#DFS模板" class="headerlink" title="DFS模板"></a>DFS模板</h2><blockquote><p>在备战蓝桥杯的过程中记住一些算法模板还是非常重要滴。</p></blockquote><pre><code class="cpp">#include &lt;iostream&gt;using namespace std;bool check()&#123;    ...&#125;void dfs()&#123;    if (满足边界条件)    &#123;                return;    &#125;    for (int i = 0; i &lt; 可扩展的路径数; i++)    &#123;        if (check())        &#123;            修改现场;            dfs(下一种情况);            还原现场;        &#125;    &#125;&#125;</code></pre><blockquote><p>模板不是固定不变的，我们要根据题目灵活地运用它。</p></blockquote><hr><h2 id="DFS经典例题"><a href="#DFS经典例题" class="headerlink" title="DFS经典例题"></a>DFS经典例题</h2><h3 id="模板题——迷宫问题"><a href="#模板题——迷宫问题" class="headerlink" title="模板题——迷宫问题"></a>模板题——迷宫问题</h3><img src="https://img-blog.csdnimg.cn/76bfafbf85ae400bbf980124689c8b74.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:67%;" /><p><strong>题目分析</strong></p><blockquote><p>迷宫问题是拿来练习DFS与BFS很经典的题目。迷宫问题有很多种问法，比如迷宫从起点到终点有没有路径，有几条，最短路径是多少。</p></blockquote><p>求从起点到终点的方案数显而易见也是要用<code>DFS</code>，遍历所有的情况。我们要考虑这样一个问题，迷宫里的某点<code>(x,y)</code>是否要被访问呢。当这点是障碍物肯定不能访问，该点不在迷宫里面也不能访问，该点访问过了那就不能访问了。(题目中有每个方格最多经过一次)。因此我们需要一个<code>check()</code>函数来判断某一点是否合法。合法我们就去访问该点。</p><blockquote><p>其实这个过程就是一个剪枝的过程，根据题目条件限制，剪掉一些不可能存在解的分支。</p></blockquote><p>另外我们该如何知道某点是障碍点呢，可以设置一个map数组来表示该迷宫。</p><ul><li>当<code>map[x][y]==1</code>时表示该点是障碍点 </li><li><code>map[x][y]==0</code>表示该点是正常点</li></ul><p><strong>AC代码</strong></p><pre><code class="cpp">#include &lt;iostream&gt;using namespace std;const int N = 100;int dx[4] = &#123;0, 0, -1, 1&#125;;int dy[4] = &#123;1, -1, 0, 0&#125;;//方向数组技巧int n, m, T;//n行m列T障碍总数int ans;//记录方案总数int sx, sy, fx, fy, l, r;//起点坐标(sx,sy)终点坐标(fx,fy)障碍点坐标(l,r)bool visited[N][N];//记录某点是否被访问过int map[N][N];//map[i][j] == 1表示是障碍bool check(int x, int y)//check某点是否合法&#123;    if (x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; m) return false;//该点出界不合法    if (map[x][y]) return false;//该点是障碍点不合法    if (visited[x][y]) return false;//该点被访问过不合法    return true;//其他情况访问合法&#125;void dfs(int x, int y)//dfs维护点的坐标参数&#123;    if (x == fx &amp;&amp; y == fy)//满足边界条件，到达终点    &#123;        ans++;//方案数+1        return;    &#125;    for (int i = 0; i &lt; 4; i++)//枚举四个方向    &#123;        int newx = x + dx[i];        int newy = y + dy[i];        if (check(newx, newy))//该点合法        &#123;            visited[x][y] = true;//将(x,y)设置成已访问,修改现场            dfs(newx, newy);//dfs下一个点            visited[x][y] = false;//回溯,恢复现场        &#125;    &#125;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; T;    cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; fx &gt;&gt; fy;    while(T--)    &#123;        cin &gt;&gt; l &gt;&gt; r;        map[l][r] = 1;    &#125;    dfs(sx, sy);//从起点开始搜索    cout &lt;&lt; ans &lt;&lt; endl;    return 0;&#125;</code></pre><blockquote><p>小伙伴们每道例题都要好好看一下AC代码噢，上面有很详细的注释。</p></blockquote><blockquote><p>这道题还可以优化下空间，可以只用maze数组来表示迷宫，同时记录迷宫内的某点是否访问过。具体见下面的代码。</p></blockquote><pre><code class="cpp">//空间优化#include &lt;iostream&gt;using namespace std;const int N = 100;int dx[4] = &#123;0, 0, -1, 1&#125;;int dy[4] = &#123;1, -1, 0, 0&#125;;//方向数组int n, m, T;int ans;int sx, sy, fx, fy, l, r;//bool visited[N][N];int map[N][N];//map[i][j] == 1表示是障碍                                                                                       bool check(int x, int y)//判断某点是否可以访问&#123;    if (x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; n) return false;    if (map[x][y] || map[x][y] == 3 ) return false;//该点是障碍点或已经访问过，不能访问    //if (visited[x][y]) return false;    return true;&#125;void dfs(int x, int y)&#123;    if (x == fx &amp;&amp; y == fy)    &#123;        ans++;        return;    &#125;    for (int i = 0; i &lt; 4; i++)    &#123;        int newx = x + dx[i];        int newy = y + dy[i];        if (check(newx, newy))        &#123;            map[x][y] = 3;//标记成已访问            dfs(newx, newy);            //点(x,y)能访问说明它不是障碍点所以回溯要让map[x][y]=0            //而不是map[x][y]=1            map[x][y] = 0;        &#125;    &#125;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; T;    cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; fx &gt;&gt; fy;    while(T--)    &#123;        cin &gt;&gt; l &gt;&gt; r;        map[l][r] = 1;    &#125;    dfs(sx, sy);    cout &lt;&lt; ans &lt;&lt; endl;    return 0;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/f0d98badf856489392bc3a7bfad24d98.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="01背包问题-DFS暴力搜索"><a href="#01背包问题-DFS暴力搜索" class="headerlink" title="01背包问题(DFS暴力搜索)"></a>01背包问题(DFS暴力搜索)</h3><img src="https://img-blog.csdnimg.cn/597a9a9e51c24576a62a7ad2d74e9b21.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16" alt="背包问题" style="zoom:67%;" /><p><strong>题目分析</strong></p><blockquote><p>01背包问题是一个很经典的问题，它有多种解法。DFS是其中一种，在学习动态规划的时候还会提到它噢。</p><p>第i件物品无非就是选和不选两种情况，在搜索的过程中DFS函数必须要记录当前处理的物品编号<code>index</code>，当前背包的容量<code>sumW</code>，当前的总价值<code>sumC</code>。</p></blockquote><ul><li>当不选第<code>index</code>个物品时，那么<code>sumW</code>,<code>sumC</code>是不变的，接着处理第<code>index+1</code>个物品，也就是<code>DFS(index+1, sumW, sumC)</code>。</li><li>当选择第<code>index</code>个物品时，<code>sumW</code>变成<code>sumW+w[index]</code>，<code>sumC</code>变成<code>sumC+v[index]</code>，接着处理第<code>index+1</code>个物品，也就是<code>DFS(index+1, sumW+w[index],sumC+v[index])</code>。边界条件也就是把最后一件物品也处理完了，即<code>index=n</code>（注意默认index从0开始）。</li></ul><p>当一条分支结束了该干什么呢，很简单呀就是判断该分支最终满不满足总重量不大于背包容量。即<code>sumW&lt;=v</code>。满足的话我们就更新价值<code>maxvalue</code>，即<code>maxvalue=max(maxvalue,sumC)</code>。</p><p><strong>AC代码</strong></p><pre><code class="cpp">//01背包问题的dfs版本#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int N = 10010;int n, v, maxvalue;int w[N], c[N];//DFS维护三个参数，正在选第index个物品，当前的总体积，当前的总价值void dfs(int index, int sumW, int sumC)&#123;    if (index == n)    &#123;        if (sumW &lt;= v)        &#123;            maxvalue = max(maxvalue, sumC);        &#125;        return;    &#125;    dfs(index + 1, sumW, sumC);//不选第index个物品    dfs(index + 1, sumW + w[index], sumC + c[index]);//选第index个物品&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; v;    for (int i = 0; i &lt; n; i++)    &#123;        cin &gt;&gt; w[i] &gt;&gt; c[i];    &#125;    dfs(0, 0, 0);//开始时对第1件物品进行选择，此时背包重量0价值也是0    cout &lt;&lt; maxvalue &lt;&lt; endl;    return 0;&#125;</code></pre><blockquote><p>当然了01背包问题如果用<code>DFS</code>来解决的话，当数据比较大时，是不能<code>AC</code>的。这道题会超出时间限制。即便经过剪枝也是无能为力的。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/b9204460d99f411dae0c590f14f4196a.png" alt="在这里插入图片描述"></p><h3 id="回溯——-USACO1-5-八皇后"><a href="#回溯——-USACO1-5-八皇后" class="headerlink" title="回溯——[USACO1.5]八皇后"></a>回溯——[USACO1.5]八皇后</h3><img src="https://img-blog.csdnimg.cn/e0392de0426f4359962c51f77cf5484f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/d9ae3a9ad53f44418de0d2a2f06c8c4b.png" alt="在这里插入图片描述" style="zoom:67%;" /><p><strong>题目分析</strong></p><blockquote><p>八皇后问题是学习回溯很经典的例题，这道题是八皇后问题的扩展，N皇后问题。也就是棋盘的大小是任意的。</p></blockquote><p>这道题<code>DFS</code>的思路还是比较清晰的，每行有且只有一个棋子，那么<code>DFS</code>可以记录下当前处理的是第几行的棋子。假设当前处理的是第<code>i</code>行的棋子，那么要枚举处在该行的棋子位置，判断哪个是合法的。<br>什么样的位置算是合法的呢，这个位置的列还有左对角线，右对角线位置都不能有棋子。那么又该如何表示这些位置呢？我们采用一维数组来分别表示列，左对角线，右对角线。列很好表示就是<code>b[j]</code>，左对角线我们可以发现行减去列的绝对值是恒定的，即<code>c[i-j+n]</code>,右对角线行加列是恒定的。即<code>d[i+j]</code>。</p><blockquote><p>小伙伴们可以自己画画图看一看噢~</p><p>当某位置放置了棋子，那么就将和它同列同对角线的位置都取为1，即<code>b[j]=1</code>,<code>c[i-j+n]=1</code>,<code>d[i+j]=1</code>。</p></blockquote><p><strong>AC代码</strong></p><pre><code class="cpp">#include &lt;iostream&gt;using namespace std;int a[100], b[100], c[100], d[100];//a[]储存解b列c左斜d右斜int n;//棋盘大小int ans;bool check(int i, int j)//检查(i,j)是否合法&#123;    if (!b[j] &amp;&amp; !c[j - i + n] &amp;&amp; !d[j + i]) return true;//b[j],c[i-j+n],d[i+j]为0说明该点可以放置棋子。    return false;&#125;void dfs(int i)//dfs第i行棋子&#123;   //边界条件    if (i &gt; n)//dfs完所有的棋子    &#123;         ans++;        if (ans &lt;= 3)//只要前三个解        &#123;            for (int i = 1; i &lt;= n; i++)//输出解            &#123;                cout &lt;&lt; a[i] &lt;&lt; &#39; &#39;;                            &#125;            cout &lt;&lt; endl;          &#125;        return;         &#125;            for (int j = 1; j &lt;= n; j++)//枚举一行的所有位置        &#123;//(i,j)点满足放棋子的条件，我们就把棋子放在(i,j)点            if (check(i, j))            &#123;                a[i] = j;//把满足解的列号存在a[i]中                b[j] = 1;//修改现场                c[ j - i + n] = 1;                d[j + i] = 1;                dfs(i + 1);//处理下一行的棋子                b[j] = 0;//回溯，恢复现场                c[j - i + n] = 0;                d[j + i] = 0;            &#125;        &#125;&#125;int main()&#123;    cin &gt;&gt; n;    dfs(1);    cout &lt;&lt; ans &lt;&lt; endl;    return 0;&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/c37e19018b064ee88491028af5bec829.png" alt="在这里插入图片描述"></p><h3 id="递归实现排列型枚举"><a href="#递归实现排列型枚举" class="headerlink" title="递归实现排列型枚举"></a>递归实现排列型枚举</h3><p><a href="https://www.acwing.com/problem/content/96/">题目链接</a></p><img src="https://img-blog.csdnimg.cn/93f1e3da7444452c827100778284df39.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:67%;" /><p><strong>题目分析</strong></p><blockquote><p>DFS可以用来处理排列组合问题。</p><p>对于全排列问题我们可以这样想，第1个位置可以放<code>1~n</code>任意一个数，第2个位置可以放除了放在第1个位置的数以外的任何一个数，以此类推。因此我们可以画出一个递归搜索树，用<code>map[]</code>来表示储存当前排列。<code>DFS</code>函数要记住当前处理的是第<code>index</code>个位置，从1到n进行遍历，看看这个数是否可以放在第<code>index</code>个位置，需要有一个判重数组<code>hashtable[x]</code>来记录<code>x</code>是否在排列里面。</p></blockquote><p><strong>AC代码</strong></p><pre><code class="cpp">#include &lt;iostream&gt;using namespace std;const int N = 11;//map[N]储存当前的排列，hashtable[N]判断某个数是否在排列里int map[N];bool hashtable[N];面。int n;void dfs(int index)//当前填第index位置&#123;    if (index == n + 1)//已经处理完1~n个位置    &#123;        for (int i = 1; i &lt;= n; i++)//输出当前排列        &#123;            cout &lt;&lt; map[i] &lt;&lt; &#39; &#39;;        &#125;        cout &lt;&lt; endl;        return;    &#125;    for (int i = 1; i &lt;= n; i++)//枚举1~n    &#123;        if (hashtable[i] == false)//当i这个数没有填在map中        &#123;            map[index] = i;//第index位置填入i这个数            hashtable[i] = true;//记i在当前排列            dfs(index + 1);//处理第index+1位置            //处理完map[index]=i的子问题，恢复现场            hashtable[i] = false;            map[index] = 0;        &#125;    &#125;&#125;int main()&#123;    cin &gt;&gt; n;    dfs(1);//从1这个数开始搜索    return 0;&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/de6462dec44d47daa0afa1023d8a0c89.png" alt="在这里插入图片描述"></p><h3 id="递归实现组合型枚举"><a href="#递归实现组合型枚举" class="headerlink" title="递归实现组合型枚举"></a>递归实现组合型枚举</h3><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/e84e6dee11d64d5688a7e07c419aa54b.png" alt="在这里插入图片描述" style="zoom: 67%;" /><img src="https://img-blog.csdnimg.cn/36278db485514eff94f4487f54653173.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:67%;" /><p><strong>题目分析</strong></p><p>组合和排列的最大区别就是组合不需要考虑顺序，也就是说<code>123</code>和<code>132</code>是一样的。<br>由于题目要求同一行的数必须按升序排序，因此可以让<code>DFS</code>函数记录当前处理的第<code>index</code>个位置，可以选的最小数<code>start</code>。</p><blockquote><p>虽然参数变成了两个，但是不需要判重数组了。</p></blockquote><p><code>DFS</code>的思路是这个样子的，假设当前处理的是第<code>index</code>个位置，这个位置可以放置<code>start~n</code>其中任意一个数。接着处理第<code>index+1</code>个位置，这个位置可以放置的最小数是前一位数的下一个数。即<code>i+1~n</code>。</p><p><strong>AC代码</strong></p><pre><code class="cpp">#include &lt;iostream&gt;using namespace std;const int N = 30;int map[N];//存储解int n, m;//dfs记录当前处理的第index个位置，可以选的最小数startvoid dfs(int index, int start)&#123;    if (index &gt; m)//m个位置都处理完了    &#123;        for (int i = 1; i &lt;= m; i++)//输出方案        &#123;            cout &lt;&lt; map[i] &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;        return;    &#125;    //第index个位置可以选择start~n里面的数    for (int i = start; i &lt;= n; i++)    &#123;        map[index] = i;        //处理index+1位置，能选择的最小数是前面选择的数+1        dfs(index + 1, i + 1);        //处理完第index位置放置i这个数的子问题后回溯。        map[index] = 0;          &#125;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    dfs(1, 1);    return 0;&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/353f2858c0d24affbfb1c9307427a79c.png" alt="在这里插入图片描述"></p><hr><h2 id="剪枝思想"><a href="#剪枝思想" class="headerlink" title="剪枝思想"></a>剪枝思想</h2><p>前面也提到过剪枝的概念，现在详细说下剪枝这种东西。我们知道<code>DFS</code>时间复杂度是很高的，如果不进行一些优化的话，在数据很大的情况下很容易就爆<code>TLE</code>。这个时候我们就可以用剪枝这种东西来优化啦~<br>在进行<code>DFS</code>的过程中对某条可以确定不存在解的分支采用直接剪短的策略。这样会大大降低计算量。一个搜索树剪掉一些分支就形象的叫它剪枝了。<br>&#x3D;&#x3D;剪枝一般都是利用题目的限制条件来确定哪些分支是不可能存在解的。&#x3D;&#x3D;</p><hr><h2 id="剪枝思想在DFS中的应用"><a href="#剪枝思想在DFS中的应用" class="headerlink" title="剪枝思想在DFS中的应用"></a>剪枝思想在DFS中的应用</h2><p>小伙伴们来回忆下01背包问题，我们是在选择完所有物品后才进行判断，看看背包总体积是否超过背包容量。是不是可以在选择的过程中就加入这一判断，这样就可以减少很多的计算量。当选第<code>index</code>件物品时，如果选上它那么背包的总体积就超出背包容量，我们一定不能选了。此时选第<code>index</code>件物品的分支就不可能存在解，直接剪掉。</p><pre><code class="cpp">//DFS维护三个参数，正在选第index个物品，当前的总体积，当前的总价值void dfs(int index, int sumW, int sumC)&#123;    if (index == n)//选择完所有的物品，最终的sumW一定不大于v    &#123;        maxvalue = max(maxvalue, sumC);        return;    &#125;    dfs(index + 1, sumW, sumC);//不选第index个物品    if (sum + w[index] &lt;= v)//剪枝    &#123;   //选第index个物品        dfs(index + 1, sumW + w[index], sumC + c[index]);    &#125; &#125;</code></pre><p>小伙伴们再来回忆下前面的组合型枚举问题，我们也可以用到剪枝来优化。可以看出要是剩下的数全都用上也满足不了一共m个数的要求，那么我们直接可以结束这个分支了。即<code>n - start + index &lt; m</code>。</p><pre><code class="cpp">void dfs(int index, int start)&#123;    if (n - start + index &lt; m) return;//剪枝    if (index &gt; m)//m个位置都处理完了    &#123;        for (int i = 1; i &lt;= m; i++)//输出方案        &#123;            cout &lt;&lt; map[i] &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;        return;    &#125;    //第index个位置可以选择start~n里面的数    for (int i = start; i &lt;= n; i++)    &#123;        map[index] = i;        //处理index+1位置，能选择的最小数是前面选择的数+1        dfs(index + 1, i + 1);        //处理完第index位置放置i这个数的子问题后回溯。        map[index] = 0;          &#125;&#125;</code></pre><blockquote><p>通过下表我们能看出剪枝之后的运行速度确实快了不少。<br><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/3f184725aed44b37bdb9b40924995a4b.png" alt="在这里插入图片描述"></p></blockquote><hr><h2 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h2><blockquote><p>深度优先搜索会优先考虑搜索的深度，就是找不到答案不回头。 当答案在解答树中比较稀疏的时候，DFS会陷入过深的情况，搜索很多无效状态，一时半会找不到解，这时候我们就可以用BFS啦~&#x3D;&#x3D;在连通性，最短路问题中常优先考虑BFS&#x3D;&#x3D;。<!--more--></p><p><code>BFS</code>和<code>DFS</code>搜索的顺序是不一样的。<code>DFS</code>前面已经讲到过，是以深度为第一关键词的，也就是说从某个结点出发总是先选择其中一个分支前进，而不管其他的分支，直到碰到死胡同才停止。然后回溯到上一个结点选择其他的分支。<br>而<code>BFS</code>搜索的顺序是这样的，从某个结点出发，总是先依次访问这个结点能直接到达的所有结点，然后再访问这些结点所能直接到达的所有结点，依次类推，直到所有的结点都访问完毕。<br>下面呢我们看一个迷宫，小伙伴们可能会对<code>BFS</code>有一个清晰的认识。<br><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/0b2c88445f9746bd8a91f1c198c15bcd.png" alt="在这里插入图片描述" style="zoom:67%;" /><br><code>BFS</code>搜索的顺序是这个样子滴~首先从起点<code>A</code>出发，它能到达的所有结点有<code>B</code>和<code>C</code>（第二层），因此接下来去访问<code>B</code>，<code>B</code>能直接到达<code>D</code>和<code>E</code>（第三层），接下来访问<code>C</code>，<code>C</code>能直接到达<code>F</code>和<code>G</code>（第三层）。第二层访问结束，接下来访问<code>D</code>，<code>D</code>能直接到达<code>I</code>和<code>G</code>和<code>H</code>（第四层）。接下来访问<code>E</code>，<code>E</code>能直接到达<code>M</code>和<code>L</code>和<code>K</code>（第四层），接着访问<code>F</code>，<code>F</code>是死胡同。接下来访问<code>G</code>，<code>G</code>是终点，搜索结束。<br>至于那些未访问过的结点，我们就不用去管它了。</p></blockquote><p>可以看出层数就是从结点A出发到达其他结点的最小步数。&#x3D;&#x3D;广度优先搜索会优先考虑每种状一个专题态的和初始状态的距离，也就是与初始状态越接近的就会越先考虑。这就能保证一个状态被访问时一定是采用的最短路径。&#x3D;&#x3D;</p><blockquote><p>其实DFS和BFS都可以从树的角度去分析。<br><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/1b178bcc540c44758a7c0b3504204c0f.png" alt="在这里插入图片描述" style="zoom:67%;" /><br><code>DFS</code>相当于树的先序遍历，<code>BFS</code>相当于树的层次遍历。<br><code>DFS</code>搜索顺序是<code>123456 </code> ，<code>BFS</code>搜索顺序是<code>125346</code>。<br>相信小伙伴们很容易就能看出来~</p></blockquote><hr><h2 id="用队列来实现BFS（模板）"><a href="#用队列来实现BFS（模板）" class="headerlink" title="用队列来实现BFS（模板）"></a>用队列来实现BFS（模板）</h2><p><code>BFS</code>的搜索过程很像一个队列，队列的特点就是先进先出。谁入队早就先访问谁。<br>我们简单的来分析一下队列模拟的过程~</p><ul><li>先把起点<code>A</code>入队，取出队首<code>A</code>，将<code>A</code>直接到达的<code>B</code>和<code>C</code>入队。队列元素有{<code>B</code>，<code>C</code>}。</li><li>再将队首<code>B</code>取出，将<code>B</code>直接到达的<code>D</code>和<code>E</code>入队。此时队列元素有{<code>C</code>，<code>D</code>，<code>E</code>}。</li><li>再将队首<code>C</code>出队，将<code>C</code>直接到达的<code>F</code>和<code>G</code>入队。此时队列元素有{<code>D</code>，<code>E</code>，<code>F</code>，<code>G</code>}。</li><li>再将队首<code>D</code>出队，将<code>D</code>直接到达的<code>I</code>和<code>J</code>和<code>H</code>入队。此时队列元素有{<code>E</code>，<code>F</code>，<code>G</code>，<code>I</code>，<code>J</code>，<code>H</code>}。</li><li>再将队首<code>E</code>出队，将<code>E</code>直接到达的<code>M</code>和<code>L</code>和<code>K</code>入队。此时队列元素有{<code>F</code>，<code>G</code>，<code>I</code>，<code>J</code>，<code>H</code>，<code>M</code>，<code>L</code>，<code>K</code>。</li><li>再将队首<code>F</code>出队，<code>F</code>没有直接相连的新节点，此时队列元素有{<code>G</code>，<code>I</code>，<code>J</code>，<code>H</code>，<code>M</code>，<code>L</code>，<code>K</code>}。</li><li>再将<code>G</code>出队，找到终点，算法结束。</li></ul><p>下面给出<code>BFS</code>的模板。</p><blockquote><p>还是那句话多记些模板对比赛是很有帮助的噢~</p></blockquote><pre><code class="cpp">void bfs()&#123;    queue&lt;int&gt; q;//一般用stl库中的queue来实现队列比较方便    q.push(起点S);//将初始状态入队    标记初始状态已入队。    while(!q.empty())//队列不为空就执行入队出队操作    &#123;        top = q.front();//取出队首        q.pop();//队首出队        for (枚举所有可扩展的状态)        &#123;            if (check())//状态合法            &#123;                q.push(temp);//状态入队                标记成已入队。            &#125;                    &#125;    &#125;</code></pre><p>对模板做几点说明</p><ol><li>建议大家用<code>stl</code>中的<code>queue</code>表示队列。操作方便。头文件要加<code>#include&lt;queue&gt;</code></li><li>要区分<code>front()</code>和<code>pop()</code>的区别,<code>front</code>的返回值是队首元素，而<code>pop</code>没有返回值。</li><li>我们常用一个新变量来储存队首元素，以便在它出队后方便下面的操作。<br><code>top = q.front()</code>。</li></ol><p>还有一个问题，我们在使用<code>BFS</code>时会设一个<code>inq</code>数组记录结点有没有入队，为什么不是记录结点有没有访问呢，不知道小伙伴们想没想过这个问题。<br>区别在于，设置成结点是否已访问，会导致有些点在队列中但是还没有被访问，由于其他结点可以到达它而将这个结点入队，导致很多结点重复入队，这是很不明智的。</p><blockquote><p>以后也会专门出一篇讲解比赛中常用的<code>STL</code>标准模板库。<br>上面对<code>BFS</code>的讲解参考胡凡《算法笔记》并补充了自己对<code>BFS</code>的理解。</p></blockquote><hr><h2 id="BFS经典例题"><a href="#BFS经典例题" class="headerlink" title="BFS经典例题"></a>BFS经典例题</h2><h3 id="模板题——迷宫最短路"><a href="#模板题——迷宫最短路" class="headerlink" title="模板题——迷宫最短路"></a>模板题——迷宫最短路</h3><img src="https://img-blog.csdnimg.cn/c246c1cf991841aba4edc48ba8f4781a.png#pic_center" alt="在这里插入图片描述" style="zoom: 80%;" /><img src="https://img-blog.csdnimg.cn/83334f78d36a4bba82a18100494088a4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5omT6JOd5qGl5p2v55qE6YCa5L-h5Lq6,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述" style="zoom:67%;" /><p><strong>题目分析</strong></p><p>该题是要求从起点到终点的最小步数。我们可以有两种解决方案，<code>DFS</code>和<code>BFS</code>。</p><ul><li>可以<code>DFS</code>所有从起点到终点的所有路径，然后取路径最短的那条。</li><li><code>BFS</code>是很理所当然的，因为求的是最小步数，涉及&#x3D;&#x3D;最短问题&#x3D;&#x3D;。</li></ul><p>我们先来看一下<code>BFS</code>该如何解决这个问题。因为是板子题嘛直接照着模板敲就好了~</p><p> <strong>AC代码（BFS）</strong></p><pre><code class="cpp">//bfs 广度优先搜索//迷宫问题 求解最短路径#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int N = 100;int n, m;//n行m列char maze[N][N];//迷宫bool inq[N][N];//记录位置(x,y)是否入队int x[4] = &#123;-1, 1, 0, 0&#125;;//增量数组int y[4] = &#123;0, 0, -1, 1&#125;;struct node&#123;    int x, y;    int step;&#125;s, t, Node;//s起点 t终点 Node临时节点bool test(int x, int y)//判断位置(x,y)是否有效&#123; //以下三种情况不能入队    if (x &gt;= n || x &lt; 0 || y &gt;= m || y &lt; 0) return false;//出界    if (maze[x][y] == &#39;*&#39;) return false;//墙壁    if (inq[x][y] == true) return false;//已入队    return true;//其余情况可以将该点入队&#125;int bfs()&#123;    queue&lt;node&gt; q;//定义队列    q.push(s);//将起点入队    while(!q.empty())//队列不为空执行    &#123;        node top = q.front();//取出队首元素        q.pop();//出队        //inq[s.x][s.y] = true;//将起点设为已入队        if (top.x == t.x &amp;&amp; top.y == t.y)//到达终点        &#123;            return top.step;返回终点的层数，即最少步数        &#125;        for (int i = 0; i &lt; 4; i++)//枚举四个方向        &#123;            int newX = top.x + x[i];            int newY = top.y + y[i];            if (test(newX, newY))//下一个点合法            &#123;                Node.x = newX; Node.y = newY;                Node.step = top.step + 1;//层数加1                q.push(Node);//将该点入队//或q.push((Node)&#123;newX,newY&#125;);                  inq[newX][newY] = true;//标记成已入队            &#125;        &#125;    &#125;    return 0;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0; i &lt; n; i++)    &#123;        getchar();//过滤掉每行的换行，不加这句是不能AC的        for (int j = 0; j &lt; m; j++)        &#123;            maze[i][j] = getchar();//读入数据        &#125;    &#125;    cin &gt;&gt; s.x &gt;&gt; s.y &gt;&gt; t.x &gt;&gt; t.y;    s.step = 0;    cout &lt;&lt; bfs() &lt;&lt; endl;    return 0;&#125;</code></pre><p>我们再来看一下如何用<code>DFS</code>来解决这个问题。用<code>DFS</code>搜索出所有可以从起点到终点的路径，并记录步数。DFS函数记录当前搜索的点的坐标<code>(x,y)</code>和所用步数<code>step</code>。用一个变量<code>minsize</code>更新最小步数<code>minsize = min(minsize, step)</code>。其余的操作其实和上一篇文章的迷宫问题求方案数是差不多的啦。小伙伴们还是不懂的话可以去看前一篇文章呀~</p><p><strong>AC代码（DFS）</strong></p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;//用PII来代替，书写方便，记得加头文件#include &lt;map&gt;typedef pair&lt;int, int&gt; PII;const int N = 100;char maze[N][N];int minsize = 10000;//更新最少步数int n, m;int dx[4] = &#123;-1, 1, 0, 0&#125;;int dy[4] = &#123;0, 0, -1, 1&#125;;bool visited[N][N];//标记某点是否已访问过PII s, t;//起点，终点bool check(int x, int y)//判断位置(x,y)是否有效&#123;    if (x &gt;= n || x &lt; 0 || y &gt;= m || y &lt; 0) return false;    if (maze[x][y] == &#39;*&#39;) return false;    if (visited[x][y] == true) return false;    return true;&#125;void dfs(int x, int y, int step)&#123;    if (x == t.first &amp;&amp; y == t.second)//到达终点    &#123;        minsize = min(minsize, step);/更新最少步数        return;    &#125;    for (int i = 0; i &lt; 4; i++)    &#123;        int newx = x + dx[i];        int newy = y + dy[i];        if (check(newx, newy))//下一个点合法        &#123;            visited[x][y] = true;//修改现场            dfs(newx, newy, step + 1);//搜索下一个点            visited[x][y] = false;//还原现场        &#125;      &#125;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0; i &lt; n; i++)    &#123;        getchar();        for (int j = 0; j &lt; m; j++)        &#123;            maze[i][j] = getchar();        &#125;    &#125;    cin &gt;&gt; s.first &gt;&gt; s.second &gt;&gt; t.first &gt;&gt; t.second;    dfs(s.first, s.second, 0);    cout &lt;&lt; minsize &lt;&lt; endl;    return 0;&#125;</code></pre><blockquote><p>对上述代码做几点说明</p><ul><li>里面用到了<code>STL</code>中的<code>pair</code>。当想要将两个元素绑在一起作为一个元素时，又不想因此定义一个结构体，那么就可以用<code>pair</code>这个小玩意啦~&#96;pair<code>里面有两个元素，类型是可以自定义的，分别是</code>first<code>,</code>second<code>。 *要注意</code>minsize<code>初始化要大一些，这样才能更新最小。 *</code>DFS<code>求解最短路问题是没有优势的。显而易见，</code>DFS<code>会搜索所有的路径，然后求出最小步数，搜索了很多无效状态，效率是非常低的，很容易就</code>TLE&#96;。</li></ul></blockquote><hr><h3 id="马的遍历"><a href="#马的遍历" class="headerlink" title="马的遍历"></a>马的遍历</h3><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/a05b6ed800fa4aeaa94f7e05612a2caf.png" alt="在这里插入图片描述" style="zoom:67%;" /><p><strong>题目分析</strong></p><p>这道题其实和前面那一道很相似，前面那一道是求从起点到终点的最短步数，而这道是求从起点(马的位置)到各个点(棋盘各个点)的最短步数。<br>那么该怎么办呢<del>很简单，从马的位置点<code>(x, y)</code>开始<code>BFS</code>，用一个<code>ans</code>数组来记录起点到达各个点时的层数，也就是最短步数。最后输出ans即可。<br>题目本身的思路还是很好想滴</del>还是有些地方需要注意一下。</p><ol><li>棋盘上的一个马的走法是有规则的，俗称”马走日”。</li></ol><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/c2656987a802484e86fbbd4d4692d2f9.png" alt="在这里插入图片描述" style="zoom:67%;" /><p>一个马可以走的位置已经用圆圈圈住啦~八个偏移量(-2,1),(-2,-1),(-1,2),(-1,-2),(2,1),(2,-1),(1,2),(1,-2)。我们可以用方向数组来表示：</p><ul><li><code>int dx[8]=&#123;-2,-2,-1,-1,2,2,1,1&#125;;</code></li><li><code>int dy[8]=&#123;1,-1,2,-2,1,-1,2,-2&#125;;</code></li></ul><ol start="2"><li>输出格式要求左对齐，宽5格。</li></ol><ul><li><code>printf(&quot;%-5d&quot;, ans[i][j]);</code></li><li><code>cout&lt;&lt;left&lt;&lt;setw(5)&lt;&lt;a[i][j]</code>但要加头文件<code>#include&lt;iomanip&gt;</code></li></ul><blockquote><p>第二个<code>cout</code>的写法大家可以试一试可不可以通过，这是我在洛谷题解里面找到的。还是推荐第一种<code>printf</code>的写法。</p></blockquote><ol start="3"><li>由于到达不了的地方要输出-1,所以我们要将<code>ans</code>数组初始化成-1。技巧<code>memset(ans, -1,sizeof(ans));</code>。</li></ol><blockquote><p>像一些方向数组，初始化数组等一些小技巧小伙伴们要好好整理一下噢，可以提高代码的效率和简洁性。</p></blockquote><p><strong>AC代码</strong></p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;iomanip&gt;#include &lt;cstring&gt;using namespace std;const int N = 450;int n, m;int ans[N][N];//储存到达每点的最少步数bool inq[N][N];//标记是否已入队int dx[8]=&#123;-2,-2,-1,-1,2,2,1,1&#125;;int dy[8]=&#123;1,-1,2,-2,1,-1,2,-2&#125;;//坐标偏移量struct node&#123;    int x;    int y;&#125;s, Node;bool check(int x, int y)&#123;    if (x &lt;= 0 || x &gt; n || y &lt;= 0 || y &gt; m) return false;//出界    if (inq[x][y] == true) return false;//已入队    return true;&#125;void bfs()&#123;    queue&lt;node&gt; q;    q.push(s);//起点入队    inq[s.x][s.y] = true;//标记起点已入队    while(!q.empty())    &#123;        node top = q.front();        q.pop();        for (int i = 0; i &lt;= 7; i++)        &#123;            int newx = top.x + dx[i];            int newy = top.y + dy[i];                     if (check(newx, newy))            &#123;                Node.x = newx; Node.y = newy;                q.push(Node);                //(Node.x,Node,y)的层数就是队头层数+1，即最短步数。                ans[Node.x][Node.y] = ans[top.x][top.y] + 1;                inq[Node.x][Node.y] = true;//标记已入队            &#125;        &#125;    &#125;&#125;int main()&#123;    memset(ans,-1,sizeof(ans));//将ans数组都设为-1    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s.x &gt;&gt; s.y;    ans[s.x][s.y] = 0;    bfs();    for (int i = 1; i &lt;= n; i++)    &#123;        for (int j = 1; j &lt;= m; j++)        &#123;          printf(&quot;%-5d&quot;, ans[i][j]);        &#125;        printf(&quot;\n&quot;);    &#125;    return 0;&#125;</code></pre><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/9aa86a15f585415685875f4cd463319f.png" alt="在这里插入图片描述" style="zoom:67%;" /><blockquote><p>当然为了节省空间这道题也可以只开一个<code>ans</code>数组。来记录最少步数和是否已入队。</p><ul><li><code>ans[x][y] != -1 </code>说明<code>(x,y)</code>点已入队；</li><li><code>ans[x][y] == -1</code>说明<code>(x,y)</code>点未入队。<br>具体代码这里就不再赘述了噢~</li></ul></blockquote><hr><h3 id="块的个数"><a href="#块的个数" class="headerlink" title="块的个数"></a>块的个数</h3><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/e6222f074a9341f99fc5ab735a2f2658.png" alt="在这里插入图片描述" style="zoom:67%;" /><p><strong>题目分析</strong></p><blockquote><p>这道题貌似有个名字叫连通块问题。</p></blockquote><p>这道题难了我好长时间，我觉得有些小伙伴肯定也会在这道题上卡一下。主要是题目意思有点难理解。我开始的时候以为块是只十字架结构的1，也就是1的上下左右都是1，然后这些1构成的就是一个块。然后看样例发现块数不太对。样例是4块。</p><p>经过长时间的绞尽脑汁的琢磨（原谅我的菜）,我才明白块说的是从某个1开始，看它的上下左右有没有1，有1的话就在看这些1的上下左右有没有1，依次类推，直到找不到1为止。这么说呢可能小伙伴们还是不太懂，那么我们举个例子吧~</p><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/30f34f3483ec4dd78ea62716fda0080c.png" alt="在这里插入图片描述" style="zoom:67%;" />样例中的四块是用圆圈圈住的这四个。以最上面的那个为例，从最左边的1开始搜索，它的右边有1个1。这个1的右边和下边有1。这些1的上下左右就没有新的1了。因此这些1组成一个块。说到这大家应该明白了许多hh~。<p>我们还可以发现单独的1也可以是一个块，不然这题答案就是3了。<br>理解了题意，思路也就很好想了。我们可以<code>BFS</code>某个1，找出与它符合块条件的所有1，通过<code>BFS</code>将这些1标记下来，进而可以不重复的搜索块的个数。</p><p><strong>AC代码</strong></p><pre><code class="cpp">#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;map&gt;using namespace std;const int N = 1000;typedef pair&lt;int, int&gt; PII;int m, n;int maze[N][N];//矩阵bool inq[N][N];//记录(x,y)是否已入队int dx[4] = &#123;-1, 1, 0, 0&#125;;int dy[4] = &#123;0, 0, -1, 1&#125;;int ans;bool check(int x, int y)&#123;    if (maze[x][y] == 0) return false;//不能访问0    if (inq[x][y] == true) return false;    if (x &lt; 1 || x &gt; m || y &lt; 1 || y &gt; n) return false;    return true;&#125;void bfs(int x, int y)//bfs的作用就是将一个块内的所有1标记一下。&#123;    PII node;    node.first = x;    node.second = y;    queue&lt;PII&gt; q;    q.push(node);    inq[x][y] = true;    while (!q.empty())    &#123;        PII temp = q.front();        q.pop();        for (int i = 0; i &lt; 4; i++)        &#123;            node.first = temp.first + dx[i];            node.second = temp.second + dy[i];            if (check(node.first, node.second))            &#123;                q.push(node);                inq[node.first][node.second] = true;            &#125;        &#125;    &#125;&#125;int main()&#123;    cin &gt;&gt; m &gt;&gt; n;    for (int i = 1; i &lt;= m; i++)    &#123;        for (int j = 1; j &lt;= n; j++)        &#123;            cin &gt;&gt; maze[i][j];        &#125;    &#125;     for (int i = 1; i &lt;= m; i++)    &#123;        for (int j = 1; j &lt;= n; j++)        &#123;//0肯定不搜索，搜索过的也不搜索            if (maze[i][j] == 1 &amp;&amp; inq[i][j] == false)            &#123;                ans++;                bfs(i, j);            &#125;        &#125;    &#125;    cout &lt;&lt; ans &lt;&lt; endl;&#125;</code></pre><blockquote><p>BFS的做法相对来说还是比较固定的，所以注释有些重复的简单的我就不再写了。<br>大家可以尝试用DFS来做一下这道题噢~ 一道题用不同的解法才能看出算法的魅力！<br><a href="https://paste.ubuntu.com/p/xXb7Pbqrmb/">DFS解答的代码我放在了这里噢</a>~</p></blockquote><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><blockquote><p>记忆化搜索的目的就是为了解决重复计算。</p></blockquote><blockquote><p>通过一个斐波那契数列和小伙伴们来聊一聊什么是记忆化搜索吧~</p></blockquote><h3 id="斐波那契数列-三种求解方法"><a href="#斐波那契数列-三种求解方法" class="headerlink" title="斐波那契数列(三种求解方法)"></a>斐波那契数列(三种求解方法)</h3><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/c7e404a186454a2d9c02aca46d45a19e.png" alt="在这里插入图片描述" style="zoom:67%;" />**Answer1. 递归实现**斐波那契数列的递归实现是比较简单的。就抓住递归的边界和递归式就没问题了。<pre><code class="cpp">#include &lt;iostream&gt;using namespace std;int n;int fib(int n)&#123;    if (n == 1) return 0;    if (n == 2) return 1;//递归边界    return fib(n - 1) + fib(n - 2);//递归式&#125;int main()&#123;    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++)    &#123;        cout &lt;&lt; fib(i) &lt;&lt; &#39; &#39;;    &#125;    cout &lt;&lt; endl;    return 0;&#125;</code></pre><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/27c23b531c4d46ae95b91a8a35d4e5b5.png" alt="在这里插入图片描述" style="zoom:67%;" />递归的时间复杂度是成指数级增长的，因此如果不进行一些优化的话，求解的`N`很大的话，很容易就`TLE`。我们可以看出fib(3)被重复计算了两次，如果我们将这个数保存起来，再遇到的时候就可以直接使用，大大简化了计算量。这就是记忆化搜索的思想。**Answer2. 记忆化搜索**<pre><code class="cpp">#include &lt;iostream&gt;using namespace std;const int N = 50;int n;int instance[N];//判断某个状态是否算出过解int dfs_m(int  n)&#123;   if (n == 1) return 0;   if (n == 2) return 1;//递归的边界条件   if (instance[n]) return instance[n];//某个状态出现过就直接输出该状态的解   return instance[n] = dfs_m(n - 1) + dfs_m(n - 2);//没算出过解就按递推式正常算&#125;int main()&#123;   cin &gt;&gt; n;   for (int i = 1; i &lt;= n; i++)   &#123;       cout &lt;&lt; dfs_m(i) &lt;&lt; &#39; &#39;;   &#125;   cout &lt;&lt; endl;   return 0;&#125;</code></pre><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/d43e3c5a5d944214a73e8d9c724d2f2a.png" alt="在这里插入图片描述" style="zoom:67%;" />记忆化搜索按照自顶向下的顺序，每求得一个状态时，就把它的解保存下来，以后再次遇到这个状态时就不用重复求解了。<p>记忆化搜索包含两个要素<strong>记忆化</strong>和<strong>搜索</strong>。</p><ul><li>沿用搜索的一般模式，本质还是用递归函数实现。</li><li>在搜索的过程中将已经得到的解保存起来，下次需要时直接用。</li></ul><p>记忆化搜索是理解DP思想很重要的基础噢，把记忆化搜索掌握明白，会很容易就入门动态规划噢~</p><blockquote><p>还有一种递推的方法，时间复杂度只有$O(n)$。递推和递归的区别在于，递推是自底向上，递归是自顶向下。</p></blockquote><p><strong>Answer3. 递推法</strong></p><pre><code class="cpp">#include &lt;iostream&gt;using namespace std;const int N = 50;int n;int ans[N];int main()&#123;    cin &gt;&gt; n;    ans[1] = 0;    ans[2] = 1;    for (int i = 3; i &lt;= n; i++)    &#123;        ans[i] = ans[i - 1] + ans[i - 2];//递推式    &#125;    for (int i =1; i &lt;= n; i++)    &#123;        cout &lt;&lt; ans[i] &lt;&lt; &#39; &#39;;    &#125;    cout &lt;&lt; endl;    return 0;&#125;</code></pre><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><blockquote><p>想到啥就说啥了，给备战蓝桥杯的小伙伴们提些建议。</p></blockquote><p>我不推荐大家去<code>leetcode</code>上刷题，因为<code>leetcode</code>的形式和蓝桥杯是不太一样的。力扣只需要写函数，输入输出已经内置好了。蓝桥杯的输入输出是需要自己写的。另外呢力扣主要是面向找工作的，题目是面试用的，不是专门打比赛的。因此题目不太适合蓝桥杯竞赛。当然了里面的题目还是很经典的，专门学某一算法是可以刷力扣的。我给大家推荐几个适合的网站还有书籍。</p><ul><li><a href="https://www.acwing.com/">ACwing网站</a></li><li><a href="https://www.luogu.com.cn/">洛谷</a></li><li><a href="https://www.dotcpp.com/oj/train/">C语言网蓝桥杯题库</a></li><li><a href="http://lx.lanqiao.cn/problemsets.page">蓝桥杯练习系统</a></li><li><a href="https://www.lanqiao.cn/problems/?sort=students_count&category_id=3">蓝桥杯官网题库</a><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/da7e876c11b741df8c7d3d5b71ab38f8.png" alt="在这里插入图片描述" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/b811a601fe264db3988a7eca92347a1f.png" alt="在这里插入图片描述" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/df58c6e5577e47d5a9fd70ca73d21e06.png" alt="在这里插入图片描述" style="zoom:67%;" /></li></ul><img src="https://cdn.jsdelivr.net/gh/xubenshan/pic-blog@main/img/a799d7696df843f3b8a57695348148cc.png" alt="在这里插入图片描述" style="zoom: 67%;" /><blockquote><p>这几个网站和书是我一直在用的，真心推荐给大家~</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>大唐杯经验分享</title>
      <link href="/2023/07/15/%E5%A4%A7%E5%94%90%E6%9D%AF%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
      <url>/2023/07/15/%E5%A4%A7%E5%94%90%E6%9D%AF%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="大唐杯备考建议分享"><a href="#大唐杯备考建议分享" class="headerlink" title="大唐杯备考建议分享"></a>大唐杯备考建议分享</h1><blockquote><p>有很多同学私信或者在群里问我该怎么去准备大唐杯，我总结了学习经验分享给大家。</p></blockquote><h2 id="一、学习路线"><a href="#一、学习路线" class="headerlink" title="一、学习路线"></a>一、学习路线</h2><h3 id="时间安排"><a href="#时间安排" class="headerlink" title="时间安排"></a>时间安排</h3><ul><li><p>二月份（选择）</p><p>准备选择题。该怎么准备。首先将培训视频中的内容全部过一遍。一个月的时间足够了。在听视频的同时将一些重点的内容记下来。哪些是重点内容，群文件里面有思维导图，里面的知识点就是重点.听视频重点听这些内容。如果二月底才开始准备，那么看完所有视频要花费的时间太多了，就不要全看了。选择重点部分看。5G网络架构与组网部署，协议与信令，5G常见参数和物理层过程（A组视频有这部分，b组可以去B站找去年的视频看这部分）这四个视频可以重点看一下。如果有同学进度比较快，那么视频看完之后就可以去做知识点总结。按照思维导图知识点的顺序，把涉及到的知识点详细整理下来。这个工作我也会做，预计三月中旬做完之后会发到QQ群里面。</p></li><li><p>三月份（选择+仿真）</p><p>如果你没有时间做知识点总结，那么直接看我总结的知识点。知识点弄熟以后，就可以刷题了。我建议先去做这两年的真题，真题已经发到群里面了，解析和参考答案会在三月初发布。通过做这些真题去感受下比赛的难度，考察的角度，重点。另外网盘里面有很多题库，有时间就多刷一下，拓展下视野。我也会把一些我觉得可能会考的题目发到群里。另外三月份重点去准备仿真，考哪些内容群文件仿真文件夹里面有。该怎么去准备呢？常规题目基站开通调测车联网B站，网盘上有很多资料。另外仔细看官方第二次直播提到的仿真内容：物理层过程，信息通信技术以及移动性管理。这几部分知识如果有时间，我也会去做总结，发到群里面。赛前一周官方会开通仿真平台，一定要把上面的题目一定弄明白，那是基础内容，考试的时候只会更难。</p></li><li><p>赛前（三月底四月初）</p><p>考前一定要再过一遍总结的知识点，以及这两年的真题。</p><p>大唐杯比赛并没有大家想的那么难，按部就班的照我说的去做，保底省二。</p></li></ul><h2 id="二、一些问题的说明"><a href="#二、一些问题的说明" class="headerlink" title="二、一些问题的说明"></a>二、一些问题的说明</h2><ol><li>看视频看不懂怎么办</li></ol><p>第一次看，听不懂很正常，不懂的一定要多听几遍。另外网盘里面有知识点资料，可以去里面找知识点，辅助理解视频内容。还有很多参考书籍也可以看看，重点看《5G系统技术原理与实现》。后面我也会在这本书中标记重点。</p><ol start="2"><li>什么时候比赛</li></ol><p>还没定，预计三月末四月初，等报名结束官方就会通知。</p><ol start="3"><li>培训视频在哪看</li></ol><p>学唐里面看。指导老师会给你开通账号密码。学唐不是官网。</p><p><a href="https://dtmobile.yunxuetang.cn/">学唐链接</a></p><p><a href="https://dtcup.dtxiaotangren.com/">官网链接</a></p><p>另外如果现在还没有学唐的账号，可以去B站看去年的省赛培训视频。内容基本一样。</p><p><a href="https://www.bilibili.com/video/BV1W3411K7FZ/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&vd_source=5940e85c0b18a907a0fdea51914b4f65">培训视频</a></p><ol start="4"><li>在哪里练习仿真</li></ol><p>仿真平台现在还没开放，考前一周会开放。</p><ol start="5"><li>今年新增的两个考点信息通信技术和工程概论该怎么去准备</li></ol><p>这两部分资料我会去整理发到群里面，另外工程概论涉及到的参考书目，等开学（2.11）我买了之后扫描成电子版发到群里面。</p><p>另外第二次官方直播有对信息通信技术的讲解，可以去看看。信息通信技术很有可能出现在仿真里面，毕竟它的占比20%。工程概论要根据思维导图在参考书目中找到对应的知识点。</p><ol start="6"><li>关于资料的说明</li></ol><p>网盘资料链接在群公告里面，里面的内容是花钱买的或者网上搜到的，做了下整理汇总。题库里面的题目答案是否正确我也不知道，因为我还没有做。里面的知识点总结我觉得很好，里面还有很多有用的东西，希望大家一定要好好利用。资料多没用什么用，不看和没有一样。</p><ol start="7"><li>可以只刷题库吗</li></ol><p>题库太多根本刷不完，另一方面考试只会有部分原题，大部分还是要靠你平时的学习积累，培训视频一定要过一遍，对知识有个大致的理解，刷题的时候效率才会高。另外今年新增了信息通信技术和工程概论知识点，这两部分没有题库。</p><h2 id="三、写在后面"><a href="#三、写在后面" class="headerlink" title="三、写在后面"></a>三、写在后面</h2><p>  创建QQ群的目的，一方面给大家分享下学习资料，不用在去花冤枉钱，买到很多4G的资料。另一方面也是希望监督自己，今年取得一个不错的名次。有句话我很喜欢，与君共勉。</p><p>  我辈既务斯业，便当专心用功。<br>我要说的就这些，后面想起别的来会继续补充。<br>希望大家今年都能取得很好的成绩！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 大唐杯 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
